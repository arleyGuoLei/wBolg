<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对Js运行机制的理解]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%AF%B9Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Js是假的多线程，子线程由一个主线程控制，子线程不能操作DOM。基本意味着：同一个时间只能做一件事 为了提高CPU的利用率，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以这个标准并没有改变JavaScript单线程的本质 就喜欢案例… 1、12345console.log(1);// 同步任务，直接进入主线程执行，所以先输出1setTimeout(function()&#123; //setTimeout是异步任务，放进任务队列，等主线程调用 console.log(3);&#125;,0);console.log(2); 结果 123 2、1234567891011console.log("start");setTimeout(function () &#123; console.log("我是异步，放进任务队列等待主线程空闲后执行");&#125;, 0);setTimeout((function () &#123; console.log("我被放进了主线程，并且执行了");&#125;)(), 10000);//??? 迷惑 10s，是情况1还是2？ 网上两种解释都有，`"我被放进了主线程，并且执行了"` 通过立即执行函数，我觉得像是情况1// 1. 运行到setTimeout就把setTimeout的回调函数放入任务队列，10s后如果主线程空闲，即运行// 2. 运行到setTimeout，先不管，10s之后把回调函数放入任务队列，主线程如果这时候空闲，即运行console.log("over"); start我被放进了主线程，并且执行了over我是异步，放进任务队列等待主线程空闲后执行 3、 1234567891011console.log('1');setTimeout(function () &#123; console.log('5');&#125;, 0);new Promise(function (resolve, reject) &#123; console.log('2'); resolve();&#125;).then(function () &#123; console.log('4');&#125;);console.log('3'); 12345 4、12345console.log("1");setTimeout(function()&#123; console.log("2");&#125;,0);while(true)&#123;&#125; 1 , 主线程忙着跑死循环，不输出2.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math的三个取整方法区别]]></title>
    <url>%2F2018%2F10%2F20%2FMath%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%96%E6%95%B4%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Math.round() ： 四舍五入 Math.ceil() ： ceil为天花板意思，所以为向上取整。 让数尽量变大 Math.floor() ： floor为地板意思，所以为向下取整。 让数尽量变小 1.Math.round()：根据“round”的字面意思“附近、周围”，可以猜测该函数是求一个附近的整数，看下面几个例子就明白。 小数点后第一位&lt;5正数：Math.round(11.46)=11负数：Math.round(-11.46)=-11 小数点后第一位&gt;5正数：Math.round(11.68)=12负数：Math.round(-11.68)=-12 小数点后第一位=5正数：Math.round(11.5)=12负数：Math.round(-11.5)=-11总结：（小数点后第一位）大于五全部加，等于五正数加，小于五全不加。 2.Math.ceil()：根据“ceil”的字面意思“天花板”去理解；例如：Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=12Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-11 3.Math.floor()：根据“floor”的字面意思“地板”去理解；例如：Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=11Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-12]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js回调函数]]></title>
    <url>%2F2018%2F10%2F20%2FJs%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[主函数的事先干完，回头再调用传进来的那个函数。ES5 到 ES6，深入了解Promise 例一： 执行结果 A -&gt; B -&gt; C 123456789101112131415function a(callbackFunction) &#123; alert("A"); var m = "C"; return callbackFunction(m);&#125;function b(m) &#123; alert("B"); return m;&#125;var result = a(b);alert("result = " + result);// 执行结果 A -&gt; B -&gt; C 例二： 先输出 我是主函数，1s后输出我是回调函数 1234567891011//定义主函数，回调函数作为参数function A(callback) &#123; callback(); console.log('我是主函数');&#125;//定义回调函数function B() &#123; setTimeout("console.log('我是回调函数')", 1000);//模仿耗时操作 &#125;A(B); ES6 中用Promise解决回调的痛点，地址：ES6总结归纳]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些小前端DEMO]]></title>
    <url>%2F2018%2F10%2F19%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%89%8D%E7%AB%AFDEMO%2F</url>
    <content type="text"><![CDATA[自己平时学习过程中写的一些demo，整理贴，持续更新ing. 计算器：https://www.i7xy.cn/code/calc/ 响应式时间轴：https://www.i7xy.cn/code/timeline/ 爱心鱼(html-cavas游戏)：https://www.i7xy.cn/code/fish/ 点名系统(js练习)：https://www.i7xy.cn/code/getName/ 安卓机器人(CSS绘制)：https://www.i7xy.cn/code/android/ 七巧板(CSS绘制)：https://www.i7xy.cn/code/SevBoard/ 关于页面：https://www.i7xy.cn/code/about/ 多种方法实现一个页面的左中右布局：https://www.i7xy.cn/code/school/exp_10_2.html 普通企业网站首页布局(学校作业)：https://www.i7xy.cn/code/school/exp_10_1.html 手风琴Tab效果：https://www.i7xy.cn/code/accordionCSS/ 坑：display属性不能设置transition效果 旋转img：https://www.i7xy.cn/code/rotateImg/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js闭包]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一般情况一个函数（函数作用域）执行完毕，里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，让作用域里面的变量，在函数执行完之后依旧保存没有被垃圾回收处理掉。 例1 12345678910111213141516171819202122232425262728293031function outer()&#123; var a = 1; function inner()&#123; return a++; &#125; return inner;&#125;var abc = outer();//outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中；//outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了；console.log(abc());//1console.log(abc());//2//因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的abc = null;//由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存；// 直接返回函数function outer2()&#123; var t = 1; return function ()&#123; console.log(t++); &#125;&#125;var a = outer2();a();//1a();//2a();//3a = null; 例2 12345678910function foo(tmp) &#123; return function () &#123; alert((tmp++)); &#125;&#125;var bar = foo(1); // bar 现在是一个闭包bar();//1bar();//2bar();//3bar();//4 例3 闭包混入立即执行函数 123456789var btnList = document.getElementsByClassName("btn"), len = btnList.length;for (var i = 0; i &lt; len; i++) &#123; (function (j) &#123; btnList[j].onclick = function () &#123; console.log("第" + j + "个按钮被点击到了") &#125; &#125;)(i)&#125; 这又哪里产生了闭包了。别急，我们一个个分析。for循环每一次都执行一个 IIEF （自执行函数），每一次变量 i 被当做参数传到IIEF中去 ， 那么这个自执行函数中创建了一个变量，参数 j 然后元素节点 btnList 绑定一个onclick事件，执行函数里面需要用到这个参数 j ，但是你又没点 ， 那么这个遍历 j 就没有被清理 ， 就一直在参数里面被保存着 ， 每一个IIEF都做一样的事情 ， 所以这个时候就产生了闭包 ， 变量 j 并没有被回收，依然在等待你使用。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js面试题整理]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[持续更新ing… 立即执行函数(IIFE) 立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了； 主要目的是做的一些封装，防止变量全局污染，以及保证内部变量的安全； javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用IIFE可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 123456var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下： 那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可（当然还有其他办法）： 12345678var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; (function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。 i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。 闭包将代码修改功能为一秒后输出1~5(在for循环之内完成)1234567for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, 1000 );&#125; 方法① 闭包 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (ii) &#123; setTimeout(function timer() &#123; console.log(ii); &#125;, 1000); &#125;)(i)&#125; 方法② let 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, 1000);&#125; 第二题 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; //面试经典问题: function onMyLoad()&#123; /* 抛出问题: 此题的目的是想每次点击对应目标时弹出对应的数字下标 0~4,但实际是无论点击哪个目标都会弹出数字5 问题所在: arr 中的每一项的 onclick 均为一个函数实例(Function 对象),这个函数实例也产生了一个闭包域, 这个闭包域引用了外部闭包域的变量,其 function scope 的 closure 对象有个名为 i 的引用, 外部闭包域的私有变量内容发生变化,内部闭包域得到的值自然会发生改变 */ var arr = document.getElementsByTagName("p"); for(var i = 0; i &lt; arr.length;i++)&#123; arr[i].onclick = function()&#123; alert(i); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="onMyLoad()"&gt; &lt;p&gt;产品一&lt;/p&gt; &lt;p&gt;产品二&lt;/p&gt; &lt;p&gt;产品三&lt;/p&gt; &lt;p&gt;产品四&lt;/p&gt; &lt;p&gt;产品五&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 用多种方法解决 方法一 123456789101112131415/*解决思路: 增加若干个对应的闭包域空间(这里采用的是匿名函数),专门用来存储原先需要引用的内容(下标),不过只限于基本类型(基本类型值传递,对象类型引用传递) */for(var i = 0;i&lt;arr.length;i++)&#123; //声明一个匿名函数,若传进来的是基本类型则为值传递,故不会对实参产生影响, //该函数对象有一个本地私有变量arg(形参) ,该函数的 function scope 的 closure 对象属性有两个引用,一个是 arr,一个是 i //尽管引用 i 的值随外部改变 ,但本地私有变量(形参) arg 不会受影响,其值在一开始被调用的时候就决定了. (function (arg) &#123; arr[i].onclick = function () &#123; //onclick函数实例的 function scope 的 closure 对象属性有一个引用 arg, alert(arg); //只要 外部空间的 arg 不变,这里的引用值当然不会改变 &#125; &#125;)(i); //立刻执行该匿名函数,传递下标 i(实参)&#125; 方法二 12345678910111213/*解决思路: 将下标作为对象属性(name:"i",value:i的值)添加到每个数组项(p对象)中*/for(var i = 0;i&lt;arr.length;i++)&#123; //为当前数组项即当前 p 对象添加一个名为 i 的属性,值为循环体的 i 变量的值, //此时当前 p 对象的 i 属性并不是对循环体的 i 变量的引用,而是一个独立p 对象的属性,属性值在声明的时候就确定了 //(基本类型的值都是存在栈中的,当有一个基本类型变量声明其等于另一个基本变量时,此时并不是两个基本类型变量都指向一个值,而是各自有各自的值,但值是相等的) arr[i].i = i; arr[i].onclick = function () &#123; alert(this.i); &#125;&#125; 方法三 123456789101112131415/*解决思路: 与解决办法一有点相似但却有点不太相似. 相似点:同样是增加若干个对应的闭包域空间用来存储下标 不同点:解决办法一是在新增的匿名闭包空间内完成事件的绑定,而此例是将事件绑定在新增的匿名函数返回的函数上 此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg */for(var i = 0; i&lt;arr.length;i++)&#123; arr[i].onclick = (function(arg)&#123; return function () &#123; alert(arg); &#125; &#125;)(i);&#125; 方法四 1234567891011/*解决思路与解决办法一相同 */for(var i = 0; i&lt;arr.length;i++)&#123; (function()&#123; var temp = i; arr[i].onclick = function () &#123; alert(temp); &#125; &#125;)();&#125; 方法五 1234567891011/*解决思路与解决办法三及四相同 */for(var i = 0;i&lt;arr.length;i++)&#123; arr[i].onclick = (function () &#123; var temp = i; return function () &#123; alert(temp); &#125; &#125;)();&#125; 方法六 12345678"use strict";//使用严格模式,否则报错 SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict modevar arr = document.getElementsByTagName("p");for(var i = 0;i&lt;arr.length;i++)&#123; let j = i;//创建一个块级变量 arr[i].onclick = function () &#123; alert(j); &#125;&#125; 本题自己做计算器的时候测试了一部分方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//方法一for (var i = 0; i &lt; numDom.length; i++) &#123; (function(val)&#123; numDom[val].onclick = function()&#123; var num = numDom[val].getAttribute("data-num"); result.value = num; &#125; &#125;)(i);&#125;// 方法二for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = function () &#123; var num = numDom[this.i].getAttribute("data-num"); result.value = num; &#125;&#125;// 方法三for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = (function (arg) &#123; return function()&#123; var num = numDom[arg].getAttribute("data-num"); result.value = num; &#125; &#125;)(i); &#125;// 方法四for (var i = 0; i &lt; numDom.length; i++) &#123; (function () &#123; var temp = i; numDom[i].onclick = function () &#123; var num = numDom[temp].getAttribute("data-num"); result.value = num; &#125; &#125;)();&#125;// 方法五for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = (function () &#123; var temp = i; return function () &#123; var num = numDom[temp].getAttribute("data-num"); result.value = num; &#125; &#125;)();&#125; 立即执行函数 和 闭包 顺序深入的一道题1、123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; 没任何坑，输出 0~4 2、12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 3、改为闭包+立即执行函数1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; 输出0~4 4、删掉立即执行函数的i，不接收传值1234567for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 5、立即执行函数12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout( (function(i) &#123;console.log(i);&#125;)(i) , i * 1000);&#125; 直接立马输出0~4 setTimeout的第一个参数应该是一个函数（所以这个等同于：setTimeout(undefined, …);） 6、JavaScript 的运行机制相关12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 2 3 5 4 1 回调函数题目：红灯三秒亮一次，绿灯两秒亮一次，黄灯一秒亮一次；如何让三个灯不断交替重复亮灯？三个亮灯函数已经存在： 1234567891011function red()&#123; console.log('red - ', new Date());&#125;function green()&#123; console.log('green - ', new Date());&#125;function yellow()&#123; console.log('yellow - ', new Date());&#125; 1、es5 回调函数实现 123456789101112131415161718192021function showRed(callback)&#123; setTimeout(function()&#123; red(); callback(showYellow); &#125;, 3000);&#125;function showGreen(callback)&#123; setTimeout(function()&#123; green(); callback(showRed); &#125;, 2000)&#125;function showYellow(callback)&#123; setTimeout(function()&#123; callback(showGreen); yellow(); &#125;, 1000)&#125;showRed(showGreen); 避免博客重复，ES6 Promise 回调至 ES6面试题整理]]></content>
      <categories>
        <category>面试集锦</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js立即执行函数(转)]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这是 JS 中的一个常见概念，面试时经常会被问到，请「用自己的语言」简述 立即执行函数是什么 立即执行函数有什么用途 立即执行函数是什么立即执行函数就是 声明一个匿名函数 马上调用这个匿名函数 上面是一个典型的立即执行函数。 首先声明一个匿名函数 function(){alert(&#39;我是匿名函数&#39;)}。然后在匿名函数后面接一对括号 ()，调用这个匿名函数。 那么为什么还要用另一对括号把匿名函数包起来呢？其实是为了兼容 JS 的语法。 如果我们不加另一对括号，直接写成 function(){alert(‘我是匿名函数’)}()浏览器会报语法错误。想要通过浏览器的语法检查，必须加点小东西，比如下面几种 12345678( function()&#123;alert('我是匿名函数')&#125;() ) // 用括号把整个表达式包起来( function ()&#123; alert('我是匿名函数')&#125; )() //!function()&#123;alert('我是匿名函数')&#125;() // 求反，我们不在意值是多少，只想通过语法检查。+function()&#123;alert('我是匿名函数')&#125;()-function()&#123;alert('我是匿名函数')&#125;()~function()&#123;alert('我是匿名函数')&#125;()void function()&#123;alert('我是匿名函数')&#125;()new function()&#123;alert('我是匿名函数')&#125;() 立即执行函数有什么用？只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免「变量污染」）。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6面试题整理]]></title>
    <url>%2F2018%2F10%2F18%2FES6%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[这年头，到处都是ES6…持续更新ing… let和const let是更完美的var，不是全局变量，具有块级函数作用域,大多数情况不会发生变量提升。const定义常量值，不能够重新赋值，如果值是一个对象，可以改变对象里边的属性值。 1、let声明的变量具有块级作用域2、let声明的变量不能通过window.变量名进行访问3、形如for(let x..)的循环是每次迭代都为x创建新的绑定 下面是var带来的不合理场景 1234567var arr = [];for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[5]() //10 在上述代码中，变量i是var声明的，在全局范围类都有效，所以用来计数的循环变量泄露为全局变量。所以每一次循环，新的i值都会覆盖旧值，导致最后输出都是10。 而如果对循环使用let语句的情况，那么每次迭代都是为x创建新的绑定代码如下： 1234567var arr = [];for (let i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[5]() //5,a[5]输出f()&#123;console.log(i);&#125;,后面加个括号代表执行f() 【拓展】当然，除了这种方式让数组找中的各个元素分别是不同的函数，我们还可以采用ES5中的闭包和立即函数两种方法。 1、采用闭包12345678910function showNum(i) &#123; return function () &#123; console.log(i) &#125;&#125;var a = []for (var i = 0; i &lt; 5; i++) &#123; a[i] = showNum(i)(); //循环输出1,2,3,4&#125;//a的每一个成员都是undefined 2、采用立即执行函数123456789var a = []for (var i = 0; i &lt; 5; i++) &#123; a[i] = (function (i) &#123; return function () &#123; console.log(i) &#125; &#125;)(i)&#125;a[2](); //2 【面试】把以下代码使用两种方法，依次输出0-9 123456789var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func(); //输出十个10&#125;) 方法一：使用立即执行函数 12345678910111213var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push( ( function (value) &#123;return function () &#123;console.log(value)&#125;&#125;(i) ) )&#125;funcs.forEach(function (func) &#123; func(); //依次输出0-9&#125;) 看方法一的时候，会有和我一样心情的人么 ↓？得，我去补习js闭包和立即执行函数的知识...了1234(function(val)&#123;console.log(val);&#125;)("这样输出很牛b？");(function () &#123; return function (val) &#123; console.log(val); &#125; &#125;)()("那我可就更牛b了");(function()&#123;return (function () &#123; return function (val) &#123; console.log(val); &#125; &#125;)()("你怎么不牛b死呢")&#125;)();( function() &#123; return (function()&#123;console.log("哈哈，我笑笑不说话");&#125;)() &#125; ) (); 方法二：使用闭包 123456789101112function show(i) &#123; return function () &#123; console.log(i) &#125;&#125;var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(show(i))&#125;funcs.forEach(function (func) &#123; func(); //0 1 2 3 4 5 6 7 8 9&#125;) 方法三：使用let 123456789var funcs = []for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func(); //依次输出0-9&#125;) 知识回顾(forEach) 123456789//forEach 回顾var numbers = [4, 9, 16, 25];numbers.forEach(function(item,index)&#123; console.log("num[" + index + "] = "+item);&#125;);// num[0] = 4// num[1] = 9// num[2] = 16// num[3] = 25 Promise一、题目：红灯三秒亮一次，绿灯两秒亮一次，黄灯一秒亮一次；如何让三个灯不断交替重复亮灯？三个亮灯函数已经存在： 1234567891011function red()&#123; console.log('red - ', new Date());&#125;function green()&#123; console.log('green - ', new Date());&#125;function yellow()&#123; console.log('yellow - ', new Date());&#125; 答案： 12345678910111213141516171819202122232425262728293031//亮灯函数function tip(fn, timer) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; fn(); resolve(); &#125;, timer); &#125;);&#125;var promise = new Promise(function (resolve) &#123; resolve();&#125;);function loop() &#123; promise.then(function () &#123; return tip(red, 3000) &#125;) .then(function () &#123; return tip(green, 2000) &#125;) .then(function () &#123; return tip(yellow, 1000) &#125;) .then( function () &#123; loop(); &#125; )&#125;loop(); 二、以下代码依次输出的内容是？ 12345678910111213setTimeout(function () &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function () &#123; console.log(4);&#125;);console.log(5); 23541 首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。 三、jQuery的ajax返回的是promise对象吗？ jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。var jsPromise = Promise.resolve($.ajax(‘/whatever.json’)); 四、promise只有2个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？ 使用promise.all() 12345678910Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。Promise.all方法接受一个数组作为参数，数组里的元素都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）示例：var p =Promise.all([p1,p2,p3]);p的状态由p1、p2、p3决定，分为两种情况。当该数组里的所有Promise实例都进入Fulfilled状态：Promise.all**返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数**。当该数组里的某个Promise实例都进入Rejected状态：Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。 五、分析下列程序代码，得出运行结果，解释其原因 123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 1243 原因：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 六、写运行结果 12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error('error!!!')&#125;)console.log('promise1', promise1)console.log('promise2', promise2)setTimeout(() =&gt; &#123; console.log('promise1', promise1) console.log('promise2', promise2)&#125;, 2000) 七、分析下列程序代码，得出运行结果，解释其原因 12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) then success1 原因：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，promise 状态一旦改变则不能再变。 八、分析下列程序代码，得出运行结果，解释其原因 1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 1 2 原因：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。 九、分析下列程序代码，得出运行结果，解释其原因 1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('once') resolve('success') &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) oncesuccess 1001success 1001 原因：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 十、分析下列程序代码，得出运行结果，解释其原因 1234567891011Promise.resolve() .then(() =&gt; &#123; return new Error('error!!!') //运行.then //throw Error('error!!!') //运行.catch 必须throw &#125;) .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) then: Error: error!!! at Promise.resolve.then 原因.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：return Promise.reject(new Error(‘error!!!’))throw new Error(‘error!!!’) 因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。 十一、分析下列程序代码，得出运行结果，解释其原因 12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 1234567891011运行结果TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3原因.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。 十二、分析下列程序代码，得出运行结果，解释其原因 1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 12345运行结果1原因.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 十三、分析下列程序代码，得出运行结果，解释其原因 123456789Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;) 1234567运行结果fail2: Error: error at success (...) at ...原因.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。 字符串一、模拟一个模板字符串的实现。 12345678let address = '北京海淀区'let name = 'lala'let str = '$&#123;name&#125;在$&#123;address&#125;上班...'// 模拟一个方法 myTemplate(str) 最终输出 'lala在北京海淀区上班...'function myTemplate(str) &#123; // try it&#125;console.log(myTemplate(str)) // lala在北京海淀区上班... 我的答案： 123456789101112131415161718let address = '华北科技学院'let name = 'Arley'let str = '$&#123;name&#125;在$&#123;address&#125;上学...'// 模拟一个方法 myTemplate(str) 最终输出 'Arley在华北科技学院上学...'function myTemplate(str) &#123; try it let arr = str.match(/\$&#123;(.*?)&#125;/g); arr.forEach(item =&gt; &#123; let itemIn = item.substring(2, item.length - 1); let val = eval(itemIn); str = str.replace(item,val); &#125;); return str; // 人家的答案- - 一句话。 // return str.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; eval(key));&#125;console.log(myTemplate(str)) // Arley在华北科技学院上学... 顺便复习一下正则，原来replace可以这么用 12345678910111213let str = '$&#123;name&#125;在$&#123;address&#125;上学...'let s = str.match(/\$\&#123;(.*?)\&#125;/g);s.forEach((item,key) =&gt; &#123; console.log(item,key);&#125;);str.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; &#123; console.log(key,match);&#125;);// $&#123;name&#125; 0// $&#123;address&#125; 1// name $&#123;name&#125;// address $&#123;address&#125; 二、实现标签化模板(自定义模板规则)。 123456789const name = 'cc'const gender = 'male'const hobby = 'basketball'// 实现tag最终输出 '姓名：**cc**，性别：**male**，爱好：**basketball**'function tag(strings) &#123; // do it&#125;const str = tag`姓名：$&#123;name&#125;，性别：$&#123;gender&#125;，爱好：$&#123;hobby&#125;`console.log(str) // '姓名：**cc**，性别：**male**，爱好：**basketball**' 我的答案： 12345678910const name = 'cc'const gender = 'male'const hobby = 'basketball'// 实现tag最终输出 '姓名：**cc**，性别：**male**，爱好：**basketball**'function tag(strings) &#123; return strings.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; eval(key));//HIHI 变聪明了 我也一句话～&#125;const str = tag("`姓名：$&#123;name&#125;，性别：$&#123;gender&#125;，爱好：$&#123;hobby&#125;`")console.log(str) // '姓名：**cc**，性别：**male**，爱好：**basketball**' 字符串更多用法到 ES6总结归纳 箭头函数123var f = x =&gt; x; f(1); //return 1var f = x =&gt; &#123;x&#125;; f(1); //function(x)=&#123;x&#125;;var f = x =&gt; (&#123;x&#125;) ;f(1);//return &#123;1&#125;(返回一个对象) 讲解在 ES6总结归纳 解构123456789// 请使用 ES6 重构一下代码// 第一题var jsonParse = require('body-parser').jsonParse// 第二题var body = request.bodyvar username = body.usernamevar password = body.password 1234567//第一题import &#123; jsonParse &#125; from 'body-parser'//第二题const &#123; username, password &#125; = request.body//const &#123; body, body: &#123; username, password &#125; &#125; = requestconsole.log(`$&#123;username&#125; - - - $&#123;password&#125;`);]]></content>
      <categories>
        <category>面试集锦</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6总结归纳]]></title>
    <url>%2F2018%2F10%2F18%2FES6%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[学习了ES6之后，感觉内容很多，保持二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。 一.变量声明const和let const 和 let 的作用域为最近相邻的{} 12345678910111213function f()&#123; if(1!==1)&#123; let test = 'hello ES6'; &#125;else&#123; console.log(test); //let和const报错，var 定义的时候不报错 // var会变量提升至函数顶部 // var 时候 test = undefined； // let 和 const 报错：Uncaught ReferenceError: test is not defined &#125;&#125;f(); const定义变量之后不可以在修改值，但如果值为对象，仍可以修改对象内的赋值。 1234567891011const name = 'a'name = 'b' // 再次赋值此时会报错// Uncaught TypeError: Assignment to constant variable.const stu = &#123; id:1, name:'lei'&#125;;stu.id = 2;console.log(stu);//不会报错 TDZ(暂时性死区) 我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。 面试题 要求：更改代码，成功输出0到9； 题目代码 12345678var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func()&#125;)//结果输入 10次10 我的投机取巧方法 12345678var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func,index) &#123; // func() console.log(index);&#125;) 方案① 123456789//ES6处理var funcs = []for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;//funcs.forEach(function (func) &#123;// func()//&#125;)funcs.forEach(func =&gt; func()) 方案② 12345678910var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function () &#123; console.log(i) &#125;)() )&#125;// funcs.forEach(function (func) &#123;// func()// &#125;)// 直接在push的时候调用函数 知识回顾123456789//forEach 回顾var numbers = [4, 9, 16, 25];numbers.forEach(function(item,index)&#123; console.log("num[" + index + "] = "+item);&#125;);// num[0] = 4// num[1] = 9// num[2] = 16// num[3] = 25 二.Promise 解决回调函数的异步痛点，用同步代码实现异步功能。 thenthen的第二个参数reject(B)，基本省略，最后用catch解决。 如果then()方法中返回了一个参数值，那么返回的Promise将会变成接收状态。如果then()方法中抛出了一个异常，那么返回的Promise将会变成拒绝状态。如果then()方法调用resolve()方法，那么返回的Promise将会变成接收状态。如果then()方法调用reject()方法，那么返回的Promise将会变成拒绝状态。如果then()方法返回了一个未知状态(pending)的Promise新实例，那么返回的新Promise就是未知状态。如果then()方法没有明确指定的resolve(data)/reject(data)/return data时，那么返回的新Promise就是接收状态，可以一层一层地往下传递。 看专业术语迷糊…看代码中的解释就懂了。 1234567891011121314151617181920212223242526272829303132333435363738394041promise = new Promise( // A ：resolve // B : reject function (A, B) &#123; setTimeout(() =&gt; &#123; // 此处不执行A或者B ， 直接return 或者 不返回任何内容，下面的then将不执行 A("获取数据完成");//A是获取成功 // 执行下面的then的第一个参数函数 //AB同时存在，只运行第一个，所以要运行B，需要注释了A B("获取数据失败"); //B是获取失败，执行下面的then的第二个参数函数 &#125;, 500) &#125;);promise.then( function (data) &#123; // 一. 运行下一个then的第一个函数 console.log("A" + data);//1. 不return 没返回任何内容 // return "返回参数值"; //2. return一个参数值 // return new Promise(function(A)&#123;A()&#125;); //3.调用了新的Promise的resolve方法，也就是A方法。注意：需要return，否则当做没情况1处理 // --------------- 下面两种运行下一个then的第二个函数 // return new Promise(function(A,B)&#123;B()&#125;);// 1.调用了新的Promise的reject方法，也就是B方法 注意要return. throw("抛出异常"); // 2.抛出异常 &#125;, function (data) &#123; console.log("B" + data);//上一个运行A()的话 此处不运行，运行B才运行。 &#125;).then( function () &#123; console.log("上面的then 1.没返回任何内容，2.或者返回参数值，3.或者调用resolve()方法"); &#125;, function () &#123; console.log("上面的then1.抛出了一个异常，2.或者调用reject()方法"); &#125;); catch catch()方法和then()方法一样，都会返回一个新的Promise对象，它主要用于捕获异步操作时出现的异常。因此，我们通常省略then()方法的第二个参数，把错误处理控制权转交给其后面的catch()函数，如下： 1234567891011121314151617181920212223promise = new Promise( function (A) &#123; setTimeout(() =&gt; &#123; A("获取数据完成"); &#125;, 500) &#125;);promise.then( function (data) &#123; console.log("上面执行了A"); throw ("我要抛出异常") &#125;).then( function () &#123; console.log("运行不到我了"); &#125;).catch( function (err) &#123; // 最后的catch()方法可以捕获在这一条Promise链上的异常 console.log(err);// 出错：reject &#125;) all 合并多个promise异步之后的数据 Promise.all里的任务列表[asyncTask(1),asyncTask(2),asyncTask(3)]，是按顺序发起的，由于它们都是异步的，互相之间并不阻塞，每个任务完成时机是不确定的。尽管如此，所有任务结束之后，它们的结果仍然是按顺序地映射到resultList里，这样就能和Promise.all里的任务列表[asyncTask(1),asyncTask(2),asyncTask(3)]一一对应起来。(转) 123456789101112131415const getRandom = () =&gt; +(Math.random() * 1000).toFixed(0);const asyncTask = taskID =&gt; new Promise(resolve =&gt; &#123; let timeout = getRandom(); console.log(`taskID=$&#123;taskID&#125; start.`); setTimeout(function () &#123; console.log(`taskID=$&#123;taskID&#125; finished in time=$&#123;timeout&#125;.`); resolve(taskID) &#125;, timeout);&#125;);Promise.all([asyncTask(1), asyncTask(2), asyncTask(3)]) .then(resultList =&gt; &#123; console.log('results:', resultList); &#125;); racePromise.race()和Promise.all()类似，都接收一个可以迭代的参数，但是不同之处是Promise.race()的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该Promise的状态就是改变的状态。就跟race单词的字面意思一样，谁跑的快谁赢。如下： 12345678910111213141516171819var p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(function(data) &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;); 三.字符串字符模板123var const = "Js";document.write("hello" + name + "!!!&lt;BR&gt;"); //es5document.write(`es6 $&#123;name&#125;!!!&lt;BR&gt;`); //es6 12345678// ES5var msg = "Hi \man!"// ES6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` ES6新加常用12345678910111213141516171819202122232425// 1.includes：判断是否包含然后直接返回布尔值 类似indexOfconst str = 'hahay'console.log(str.includes('y')) // true// 2.repeat: 获取字符串重复n次const str = 'he'console.log(str.repeat(3)) // 'hehehe'//如果你带入小数, Math.floor(num) 来处理// s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理// 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束const str = 'hello world!'console.log(str.startsWith('hello')) // trueconsole.log(str.endsWith('!')) // true// 4. padStart 和 padEnd 填充字符串，应用场景：时分秒// 上面代码中，padStart 和 padEnd 一共接受2个参数，第一个是用来指定字符串的最小长度，第二个参数是用来补全长度的字符串。// 1）如果原字符串长度等于或大于指定得最小长度，则返回原字符串。setInterval(() =&gt; &#123; const now = new Date() const hours = now.getHours().toString() const minutes = now.getMinutes().toString() const seconds = now.getSeconds().toString() console.log(`$&#123;hours.padStart(2, 0)&#125;:$&#123;minutes.padStart(2, 0)&#125;:$&#123;seconds.padStart(2, 0)&#125;`)&#125;, 1000) 四.函数函数默认参数123function test(num = 666) &#123; console.log(num)&#125; 箭头函数三个特点 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字 当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如: var people = name =&gt; &#39;hello&#39; + namevar people = () =&gt; &#39;hello i7xy&#39; 1234var hiPeople = (name) =&gt; &#123; const hi = 'hello' + name return hi&#125; 箭头函数需要注意的地方当要求动态上下文的时候，就不能够使用箭头函数，也就是this的固定化。 1、在使用=&gt;定义函数的时候，this的指向是定义时所在的对象，而不是使用时所在的对象；2、不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误；3、不能够使用arguments对象；4、不能使用yield命令； 12345678910111213class Animal &#123; constructor() &#123; this.type = "animal"; &#125; say(val) &#123; setTimeout(() =&gt; &#123; console.log(this); //Animal console.log(this.type + ' says ' + val); &#125;, 1000) &#125;&#125;var animal = new Animal();animal.say("hi"); //animal says hi 五.对象拓展（转）对象初始化简写 ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如： 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;;&#125; 键值对重名，ES6可以简写如下： 123456function people(name, age) &#123; return &#123; name, age &#125;;&#125; ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法： 123456const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125;&#125; ES6通过省略冒号与 function 关键字，将这个语法变得更简洁 123456const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125;&#125; ES6 对象提供了 Object.assign()这个方法来实现浅复制。Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}1234567891011121314const objA = &#123; name: 'cc', age: 18 &#125;const objB = &#123; address: 'beijing' &#125;const objC = &#123;&#125; // 这个为目标对象const obj = Object.assign(objC, objA, objB)// 我们将 objA objB objC obj 分别输出看看console.log(objA) // &#123; name: 'cc', age: 18 &#125;console.log(objB) // &#123; address: 'beijing' &#125;console.log(objC) // &#123; name: 'cc', age: 18, address: 'beijing' &#125;console.log(obj) // &#123; name: 'cc', age: 18, address: 'beijing' &#125;// 是的，目标对象ObjC的值被改变了。// so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象&#123;&#125;Object.assign(&#123;&#125;, objC, objA, objB) 六.更方便的数据访问–解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下： 1234567const people = &#123; name: 'man', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象const people = &#123; name: 'man', age: 20&#125;const &#123; name, age &#125; = peopleconsole.log(`$&#123;name&#125; --- $&#123;age&#125;`)//数组const color = ['red', 'blue']const [first, second] = colorconsole.log(first) //'red'console.log(second) //'blue' 七.Spread Operator 展开运算符…1234567891011121314//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c"// const objA = &#123; name: 'cc', age: 18 &#125;// const objB = &#123; address: 'beijing' &#125;// const objC = &#123;&#125; // 这个为目标对象// const obj = Object.assign(objC, objA, objB) 有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项 12345678910111213//数组const number = [1,2,3,4,5]const [first, ...rest] = numberconsole.log(rest) //2,3,4,5//对象const user = &#123; username: 'lux', gender: 'female', age: 19, address: 'peking'&#125;const &#123; username, ...rest &#125; = userconsole.log(rest) //&#123;"address": "peking", "age": 19, "gender": "female" 八.SET - 数组去重123const set = new Set([1,2,3,4,4])console.log([...set] )// [1,2,3,4]console.log(Array.from(new Set([2,3,3,5,6]))); //[2,3,5,6] 九.import 和 export12345678910111213141516171819202122232425//A.jsexport let A = 1;export function Test()&#123;&#125;export class Hello&#123;cat()&#123;&#125;&#125;//importX.js// import &#123; A, Test, Hello &#125; from './A';import * as lesson from './A';console.log(lesson.A, lesson.Test, lesson.Hello)// 更好的写法let A = 1;function Test()&#123;&#125;class Hello&#123;cat()&#123;&#125;&#125;export default &#123; A, Test, Hello&#125;// importX.jsimport Lesson from './A' 十.class]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次原生css3实现响应式布局 - timeLine]]></title>
    <url>%2F2018%2F10%2F06%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8E%9F%E7%94%9Fcss3%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80-timeLine%2F</url>
    <content type="text"><![CDATA[慕课网响应式布局教程 - 时间轴实战 1.分大 - 中 - 小 三种样式 大 &gt;768px 中 425 &lt; x＜=768 小 &lt;=425px 2.老师给的设计图 我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Time-line&lt;/title&gt; &lt;link rel="stylesheet" href="./css/normalize.css"&gt; &lt;link rel="stylesheet" href="./css/main.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;h1 class="title"&gt;Responsive Timeline&lt;/h1&gt; &lt;/header&gt; &lt;section class="main"&gt; &lt;ul class="item-all"&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;14:10&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Cumque, iste.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur eius illum libero maiores nam optio, praesentium provident sit suscipit! Aliquam animi asperiores consequuntur eaque facere, fugiat ipsa, ipsum libero magni officiis praesentium provident sequi suscipit vitae voluptatem voluptates voluptatibus. Beatae commodi cumque dignissimos doloremque ea facere id impedit ipsum iure mollitia natus pariatur, possimus quidem tempora vero? Dolorem, enim eos esse et eveniet excepturi iste laboriosam laudantium odit sit temporibus velit, veritatis voluptatem. Alias animi dicta ducimus, ipsam quidem repudiandae sint? Architecto atque beatae, consequuntur debitis nihil odit quo similique tenetur voluptates! Ad beatae, commodi illo molestiae quisquam sed veniam.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;15:30&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Neque, odio.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur dolorum enim id maxime quas qui reprehenderit sequi unde voluptatum. Accusantium consectetur ea impedit ipsam laboriosam perspiciatis quam! Architecto asperiores dolores doloribus ducimus enim esse fuga, harum iste iure libero maiores odit, officiis quae quibusdam quis sint veniam. Aperiam cupiditate, enim esse eum exercitationem fuga iste iusto perspiciatis sequi voluptatem! Aliquid animi asperiores at corporis, dolores eligendi laudantium libero minus non nostrum odio porro quo rem repellat sapiente sed sint, unde?&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;16:40&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur autem cumque delectus, dolor doloribus ducimus eius error esse expedita explicabo hic incidunt laboriosam laudantium non obcaecati odio quae quam, quidem rem similique sit sunt temporibus ullam veritatis voluptate voluptatem, voluptatum. Aut commodi, debitis distinctio dolorum, ducimus eius eum excepturi facere fuga impedit molestias nam odio optio praesentium quibusdam quisquam reprehenderit repudiandae rerum saepe sint suscipit totam veniam. At dolores maxime officia quas repellendus rerum tempora tenetur? Aspernatur consectetur doloremque ea inventore maxime, sequi suscipit! Distinctio et numquam temporibus.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/** 大 &gt;768px* 中 425 &lt; x＜=768* 小 &lt;=425px*//*-----------------*/.cleanfix:before,.cleanfix:after &#123; display: table; content: ' ';&#125;.cleanfix:after &#123; clear: both;&#125;/*-----------------*/.container &#123; width: 100%; margin: 0 auto;&#125;@media screen and (min-width: 768px) &#123; .container &#123; max-width: 1080px; width: 90%; &#125;&#125;@media screen and (max-width: 768px)&#123; .container&#123; box-sizing: border-box; padding: 0 1rem; &#125;&#125;.title &#123; color: #47a3da; font-weight: 500; margin-top: 2.5rem;&#125;@media screen and (max-width: 768px)&#123; .title&#123; text-align: center; margin-top: 1.5rem; &#125;&#125;.main &#123; margin-top: 5rem; position: relative;&#125;.item-all:before &#123; position: absolute; content: ' '; width: .5rem; height: 100%; background-color: #afdcf8; left: 25%; top: 0; bottom: 0;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item-all:before &#123; left: 22%; &#125;&#125;@media screen and (max-width: 425px) &#123; .item-all:before &#123; display: none; &#125; .main &#123; margin-top: 2rem; &#125;&#125;.item-all .item:nth-child(2n) .right-wrap,.item-all .item:nth-child(2n) .item-right:before &#123; background-color: #3594CB;&#125;.item-all .item:nth-child(2n+1) .right-wrap,.item-all .item:nth-child(2n+1) .item-right:before &#123; background-color: #6CBFEE;&#125;.item-all&#123; padding: 0;&#125;.item &#123; list-style: none; position: relative; margin-bottom: 2rem;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item &#123; margin-bottom: 1rem; &#125;&#125;.item-left &#123; float: left; width: 30%; padding-right: 5rem; box-sizing: border-box; position: absolute; top: 0; bottom: 0;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item-left &#123; padding-right: 10%; &#125;&#125;.item-right &#123; float: right; width: 70%; position: relative;&#125;.left-data &#123; font-size: 1rem; color: #bdd0db; display: block; text-align: right;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .left-data &#123; text-align: left; &#125;&#125;.item-all .item:nth-child(2n) .left-time &#123; color: #3594CB;&#125;.item-all .item:nth-child(2n+1) .left-time &#123; color: #6CBFEE;&#125;.left-time &#123; display: block; text-align: right; font-size: 3rem; font-weight: 400; margin-top: .2rem;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .left-time &#123; font-size: 2rem; text-align: left; &#125;&#125;.right-wrap &#123; /*background-color: #6CBFEE;*/ border-radius: .4rem; padding: 2rem;&#125;.item-right:before &#123; position: absolute; content: ' '; display: block; width: 1.2rem; height: 1.2rem; /*background-color: #6CBFEE;*/ left: -.5rem; top: 2rem; transform: rotate(45deg);&#125;.right-title &#123; color: #ffffff; font-weight: 600; font-size: 1.5rem;&#125;.right-title:after &#123; content: ' '; display: block; height: 1px; background-color: #ffffff; margin-top: .8rem;&#125;.right-desc &#123; color: #ffffff; line-height: 1.5;&#125;@media screen and (max-width: 425px) &#123; .item-left &#123; float: none; width: 100%; display: block; position: relative; &#125; .item-right &#123; float: none; width: 100%; display: block; position: relative; margin-top: 1rem; &#125; .left-time&#123; text-align: left; font-size: 2rem; &#125; .left-data&#123; text-align: left; &#125; .item-right:before &#123; position: absolute; content: ' '; display: block; width: 1.2rem; height: 1.2rem; /* background-color: #6CBFEE; */ left: 2rem; top: -.5rem; transform: rotate(45deg); &#125;&#125; 老师的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en" class="no-js"&gt;&lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;title&gt;Responsive Timeline&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" type="text/css" href="css/style.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header class="clearfix"&gt; &lt;h1&gt;Responsive Timeline&lt;/h1&gt; &lt;/header&gt; &lt;div class="main"&gt; &lt;ul class="tmtimeline"&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-05-01&lt;/span&gt; &lt;span&gt;18:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Cupiditate, neque.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid architecto at atque consequatur consequuntur corporis dolor facere, fuga laborum natus, nihil rem repudiandae temporibus ullam ut veniam veritatis voluptas voluptates. Aliquam assumenda eius exercitationem hic ipsa numquam quam quis ratione, repellat, reprehenderit sunt, ullam! Accusamus, ad aliquid asperiores aspernatur at consequuntur cupiditate delectus deleniti dignissimos doloremque ea enim error, et excepturi explicabo facere fuga illo impedit iste laudantium minima molestias non nulla odit optio quos repellat sequi similique tempore vel veniam, vero voluptates voluptatum! At, cum deleniti, eaque enim fugiat illo in molestiae necessitatibus non obcaecati perferendis possimus temporibus tenetur.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-04-01&lt;/span&gt; &lt;span&gt;12:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Amet beatae cupiditate debitis doloribus eius eligendi, error est eveniet ipsam laborum laudantium magnam natus non omnis placeat praesentium quas repellat reprehenderit saepe soluta sunt temporibus totam vero voluptatem voluptatibus? Ab atque consequuntur cupiditate dolorum ducimus eligendi error eveniet excepturi facilis harum, in iste nihil obcaecati officiis, quas quasi qui quia quos reiciendis rem rerum sapiente totam unde voluptatibus voluptatum? Dolor dolore dolorum ducimus et fugit iusto modi odit quibusdam vitae voluptas!&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-03-21&lt;/span&gt; &lt;span&gt;11:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. At dignissimos dolor dolores error quisquam vero, voluptatem. Accusantium consectetur consequuntur debitis dicta dolor dolores fugit laborum libero molestiae, natus nobis odit. Ab aliquid consequuntur, dolorum eius eligendi impedit ipsam neque odit, perspiciatis quis, similique unde voluptate! Corporis necessitatibus odit repellendus tempora.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-02-11&lt;/span&gt; &lt;span&gt;9:45&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti, dolorem id inventore iste odit perferendis provident? A cupiditate doloribus, enim et fuga iste nemo non nostrum omnis perspiciatis praesentium provident, quas repellendus rerum sit tempore voluptates. Aliquam distinctio fugit hic maiores ullam voluptate! Aspernatur autem blanditiis deleniti dolor dolores dolorum enim et illum ipsa iure laboriosam, natus officiis ullam voluptas?&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-02-11&lt;/span&gt; &lt;span&gt;9:45&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptas?&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Error eum ex iusto magnam obcaecati. Adipisci deserunt dicta dolorem ea enim et eum labore laboriosam, quos reprehenderit sequi vero vitae voluptatum.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207*, *:after, *:before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;body, html &#123; margin: 0; padding: 0; font-size: 100%;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: table;&#125;.clearfix:after &#123; clear: both;&#125;body &#123; font-family: 'Lato', Calibri, Arial, sans-serif; color: #47a3da;&#125;a &#123; color: #f0f0f0; text-decoration: none;&#125;a:hover &#123; color: #000;&#125;.main,.container &gt; header &#123; width: 96%; max-width: 70em; margin: 0 auto; padding: 0 2em 3em 2em;&#125;.container &gt; header &#123; padding: 3em 2em 2em;&#125;.container &gt; header h1 &#123; font-weight: 400;&#125;@media screen and (max-width: 55em) &#123; .main, .container &gt; header &#123; width: 98%; padding: 0 2em 1em 2em; &#125; .container &gt; header h1 &#123; text-align: center; &#125;&#125;/* Timeline */.tmtimeline &#123; position: relative; margin: 30px 0 0 0; padding: 0; list-style: none;&#125;.tmtimeline:before &#123; content: ''; position: absolute; top: 0; bottom: 0; left: 20%; width: 10px; margin-left: -10px; background: #afdcf8;&#125;.tmtimeline &gt; li &#123; position: relative;&#125;.tmtimeline &gt; li .tmtime &#123; position: absolute; display: block; width: 25%; padding-right: 100px;&#125;.tmtimeline &gt; li .tmtime span &#123; display: block; text-align: right;&#125;.tmtimeline &gt; li .tmtime span:first-child &#123; font-size: 0.9em; color: #bdd0db;&#125;.tmtimeline &gt; li .tmtime span:last-child &#123; font-size: 2.9em; color: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmtime span:last-child &#123; color: #6cbfee;&#125;.tmtimeline &gt; li .tmlabel &#123; position: relative; margin: 0 0 15px 25%; padding: 2em; color: #fff; font-size: 1.2em; font-weight: 300; line-height: 1.4; border-radius: 5px; background: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmlabel &#123; background: #6cbfee;&#125;.tmtimeline &gt; li .tmlabel h2 &#123; margin-top: 0; padding: 0 0 10px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.4);&#125;.tmtimeline &gt; li .tmlabel:after &#123; content: " "; position: absolute; top: 10px; right: 100%; height: 0; width: 0; pointer-events: none; border: 10px solid transparent; border-right-color: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmlabel:after &#123; border-right-color: #6cbfee;&#125;@media screen and (max-width: 55em) &#123; .tmtimeline &gt; li .tmtime &#123; padding-right: 65px; &#125; .tmtimeline &gt; li .tmtime span:last-child &#123; font-size: 1.5em; &#125;&#125;@media screen and (max-width: 40em) &#123; .tmtimeline:before &#123; display: none; &#125; .tmtimeline &gt; li .tmtime &#123; position: relative; width: 100%; padding: 0 0 20px 0; &#125; .tmtimeline &gt; li .tmtime span &#123; text-align: left; &#125; .tmtimeline &gt; li .tmlabel &#123; margin: 0 0 30px 0; padding: 1em; font-weight: 400; font-size: 95%; &#125; .tmtimeline &gt; li .tmlabel:after &#123; top: -20px; right: auto; left: 20px; border-right-color: transparent; border-bottom-color: #3594cb; &#125; .tmtimeline &gt; li:nth-child(odd) .tmlabel:after &#123; border-right-color: transparent; border-bottom-color: #6cbfee; &#125; .tmtimeline &gt; li .tmicon &#123; position: relative; float: right; left: auto; margin: -55px 5px 0 0; &#125;&#125; normalize123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css *//** * 1. Change the default font family in all browsers (opinionated). * 2. Prevent adjustments of font size after orientation changes in IE and iOS. */html &#123; font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/** * Remove the margin in all browsers (opinionated). */body &#123; margin: 0;&#125;/* HTML5 display definitions ========================================================================== *//** * Add the correct display in IE 9-. * 1. Add the correct display in Edge, IE, and Firefox. * 2. Add the correct display in IE. */article,aside,details, /* 1 */figcaption,figure,footer,header,main, /* 2 */menu,nav,section,summary &#123; /* 1 */ display: block;&#125;/** * Add the correct display in IE 9-. */audio,canvas,progress,video &#123; display: inline-block;&#125;/** * Add the correct display in iOS 4-7. */audio:not([controls]) &#123; display: none; height: 0;&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Add the correct display in IE 10-. * 1. Add the correct display in IE. */template, /* 1 */[hidden] &#123; display: none;&#125;/* Links ========================================================================== *//** * 1. Remove the gray background on active links in IE 10. * 2. Remove gaps in links underline in iOS 8+ and Safari 8+. */a &#123; background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */&#125;/** * Remove the outline on focused links when they are also active or hovered * in all browsers (opinionated). */a:active,a:hover &#123; outline-width: 0;&#125;/* Text-level semantics ========================================================================== *//** * 1. Remove the bottom border in Firefox 39-. * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Prevent the duplicate application of `bolder` by the next rule in Safari 6. */b,strong &#123; font-weight: inherit;&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * Add the correct font style in Android 4.3-. */dfn &#123; font-style: italic;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/** * Add the correct background and color in IE 9-. */mark &#123; background-color: #ff0; color: #000;&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10-. */img &#123; border-style: none;&#125;/** * Hide the overflow in IE. */svg:not(:root) &#123; overflow: hidden;&#125;/* Grouping content ========================================================================== *//** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,pre,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct margin in IE 8. */figure &#123; margin: 1em 40px;&#125;/** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/* Forms ========================================================================== *//** * 1. Change font properties to `inherit` in all browsers (opinionated). * 2. Remove the margin in Firefox and Safari. */button,input,select,textarea &#123; font: inherit; /* 1 */ margin: 0; /* 2 */&#125;/** * Restore the font weight unset by the previous rule. */optgroup &#123; font-weight: bold;&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video` * controls in Android 4. * 2. Correct the inability to style clickable types in iOS and Safari. */button,html [type="button"], /* 1 */[type="reset"],[type="submit"] &#123; -webkit-appearance: button; /* 2 */&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Change the border, margin, and padding in all browsers (opinionated). */fieldset &#123; border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Remove the default vertical scrollbar in IE. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10-. * 2. Remove the padding in IE 10-. */[type="checkbox"],[type="radio"] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type="search"] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding and cancel buttons in Chrome and Safari on OS X. */[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * Correct the text style of placeholders in Chrome, Edge, and Safari. */::-webkit-input-placeholder &#123; color: inherit; opacity: 0.54;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;]]></content>
      <categories>
        <category>布局艺术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display: inline-block 导致换行]]></title>
    <url>%2F2018%2F10%2F02%2Fdisplay-inline-block-%E5%AF%BC%E8%87%B4%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[display: inline-block 时候，70% + 30% &gt; 100% 换行原因:标签与标签之间的换行会占据一定大小。 比如:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;`display: inline-block`导致换行&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; .containter .item:nth-child(1) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: red; height: 100px; &#125; .containter .item:nth-child(2) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: yellow; height: 100px; &#125; .containter .item:nth-child(3) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: blue; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="containter"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;!-- 因为item div之后的换行导致 --&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方法: 123.containter &#123; font-size: 0;&#125;]]></content>
      <categories>
        <category>布局艺术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-shadow 的参数（模糊距离与阴影尺寸的区别）]]></title>
    <url>%2F2018%2F10%2F02%2Fbox-shadow-%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E6%A8%A1%E7%B3%8A%E8%B7%9D%E7%A6%BB%E4%B8%8E%E9%98%B4%E5%BD%B1%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[box-shadow: h-shadow v-shadow blur spread color inset; box-shadow: 水平位移 垂直位移 模糊距离 阴影尺寸 color inset; 阴影尺寸:增加边框的宽度(不占据k空间) 模糊距离:模糊的圆的半径 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .shadow &#123; box-shadow:green 0 0 100px ; height: 100px; width: 100px; margin: 30px; float: left; &#125; .shadow_inset&#123; box-shadow: 0 0 100px red inset ; height: 100px; width: 100px; margin: 30px; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="shadow"&gt; &lt;/div&gt; &lt;div class="shadow_inset"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课 [所向披靡的响应式] 学习笔记]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%85%95%E8%AF%BE-%E6%89%80%E5%90%91%E6%8A%AB%E9%9D%A1%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[教程地址：慕课-所向披靡的响应式开发 1.判断IE版本 -&gt; IE低版本提示兼容,更新浏览器 123&lt;!--[if lte IE 8]&gt;&lt;p&gt;版本低&lt;/p&gt;&lt;![endif]--&gt; 2.lte 小于等于,gte 大于等于 3.id-&gt;首字母小写的驼峰命名,class-&gt; -连接单词 4.必不可少的图片img引入,k而有可无的装饰性图片css中用样式引入 5.选择文本之后的样式设置 1234::selection&#123; background-color: red; text-shadow: none;&#125; 6.清除浮动的方法 - 触发BFC 尾部添加div 1&lt;div style="clear:both;"&gt;&lt;/div&gt; 父元素设置样式(子元素设置了浮动) 1overfloat:hidden;//auto 或 1float:left; 最佳方法,在父元素结点上加入类clearfix,然后通过after除 1234567.clearfix:after&#123; content: ' '; display: block; height: 0; visibility: hidden; clear: both;&#125; 改进: 12345.clearfix:after&#123; content: ' '; display: table; clear: both;&#125; 7.防止上下margin叠加 12345678.clearfix:after,.clearfix:before&#123; content: ' '; display: table;&#125;.clearfix:after&#123; clear: both;&#125; 8.line-height设置高度为rem单位时候会出现高度不符合预期,尽量用px设置(因为浏览器有字体大小下限) 9.第一个li不设置左边框,后面的li设置:+ 1ul li + li&#123;&#125; 10.display: inline-block导致换行:标签与标签之间的换行会占据一定大小,导致换行. 比如:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;`display: inline-block`导致换行&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; .containter .item:nth-child(1) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: red; height: 100px; &#125; .containter .item:nth-child(2) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: yellow; height: 100px; &#125; .containter .item:nth-child(3) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: blue; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="containter"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;!-- 因为item div之后的换行导致 --&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方法: 123.containter &#123; font-size: 0;&#125; 11.文本一行显示,超过的省略号截断.123text-overflow: ellipsis;overflow: hidden;white-space: nowrap; 12.为css自动加入浏览器识别前缀:autoprefixer 13.媒体查询 所以设置的常有：1234@media screen and (min-width:1200px)@media screen and (min-width:992px)@media screen and (min-width:768px)@media screen and (min-width:480px) 14.响应式图片 为了兼容所有低版本浏览器,引入picturefill库 12345&lt;picture&gt; &lt;source srcset="bigest.png" media="(min-width:50em)"&gt; &lt;source srcset="big.png" media="(min-width:30em)"&gt; &lt;img srcset="other.png" alt=""&gt;&lt;/picture&gt; 15.在线压缩图片:pngtiny 16.nodejs和npm npm install xxx -&gt; npm i xxxnpm i xxx -gnpm i xxx --savenpm i xxx --save-dev 17.modernizr 18.caniuse 19.browsersync 20.gulpjs 21.Webstorm常用 &gt;,+,^,*,() #,.,[] $ {},loremctrl + back 删除当前行ctrl + alt + 回车 在上方插入一行ctrl + +/- 折叠/打开代码ctrl + shift + +/- 折叠/打开所有代码]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库Mysql期末复习]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一章 数据库(DB),数据库系统(DBS)和数据库管理系统(DBMS)之间的关系是()。A. DBS包括DB和DBMS B. DBMS包括DB和DBSC. DB包括DBS和DBMS D. DBS就是DB,也就是DBMS 下面列出的数据库管理技术发展的三个阶段中,没有专门的软件对数据进行管理的是( )。I.人工管理阶段 II.文件系统阶段 III.数据库阶段A.I 和 II B.只有 IIC.II 和 III D.只有 I 数据管理技术发展的三个阶段 人工管理阶段 文件系统阶段 数据库系统阶段(数据结构化、共享性高、独立性高;安全性、完整性好) 下列四项中,不属于数据库系统特点的是( ) 。A.数据共享 B.数据完整性C.数据冗余度高 D.数据独立性高 三级模式 :外模式、模式、内模式 二级映像 外模式/模式 - 逻辑 模式/内模式 - 物理 2种应用结构: C/S结构 B/S结构 用户或应用程序看到的那部分局部逻辑结构或特征的描述是___。A.模式B.物理模式C.外模式D.内模式 数据库系统的三级模式中,表达物理数据库的是___。A.外模式B.模式C.用户模式D.内模式 要保证数据库的逻辑数据独立性,需要修改的是___。A.模式与外模式之间的映射 B.模式C.模式与内模式之间的映射 D.三级模式 第二章 设某医院病房计算机管理中心需要输入如下信息:科室:科名、科室地址、科室电话;病房:病房号、病房状况、所属科室;医生:姓名、职称、年龄、工号、科室;病人:病历号、姓名、性别、诊断、住院时间 其中一个科室有多个病房、多个医生,一个病房只能属于一个科室,一个医生只属于一个科室,但可以负责多名病人的诊治,一个病人的主管医生只有一个。 数据处理三层抽象 概念层 逻辑层 物理层 数据模型组成要素 数据结构 数据操作 数据的完整性约束条件 数据模型的三个组成要素中,不包括__。A.完整性规则B.数据结构C.数据操作D.并发控制 区分不同实体的依据是___。A.名称B.属性C.对象D.概念 数据库的概念模型独立于___。A.具体的机器和DBMS B.E-R图C.信息世界 D.现实世界 作业题P12 第1、2、3题P26 第3、4题P30 三、设计性实验 二选一 第三章 关系模型与规范化理论 一个关系只有一个___。A.候选码B.外码C.码D.主码 关系模型中,一个码是___组成。A.可由多个任意属性B.至多由一个属性C.由一(多)个属性组成,其值唯一标识关系中一个元组D.以上都不是 现有如下关系,下列_属于用户定义的完整性。医疗(医生编号,医生姓名,患者编号,性别,诊断日期,诊断结果)A.医生编号做主码B.医生的姓名不能空C.患者编号要与患者关系中的患者编号对应D.性别只能取“男”或“女” 参加并运算的两个关系___。A.属性个数可以不相同B.属性个数、相应属性的域相同C.一个关系的属性包含另一个关系的属性D.属性名必须相同 [练习1]查询选修了2号课程的学生的学号。 [练习2]查询选修了2号课程的学生的姓名和系部。 [练习3]查询没选修2号课程的学生信息。 [练习4]查询同时选修2号课和3号课的学生学号。 查询选修了全部课程的学生的学号和姓名。 给定关系R和S如下 设有3个关系分别是S、C和SC,下面关系代数表达式是什么含义? 关系数据库规范化是为解决关系数据库中的___问题而引入的。A.操作异常和数据冗余B.提高查询速度C.减少数据操作的复杂性D.保证数据的安全性和完整性]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE实现操作系统进程调度模拟]]></title>
    <url>%2F2018%2F11%2F01%2FVUE%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[《操作系统》课程综合性实验：用C语言（或其它语言，如Java）编程实现对N个进程采用某种进程调度算法（如动态优先权调度算法、先来先服务算法、短进程优先算法、时间片轮转调度算法）调度执行的模拟。 本项目由js(es6)实现了先来先服务,抢占式短进程优先以及时间片轮转调度算法,更多的内容等写实验报告之后在更新。先贴代码和学到的一些东西。 技术栈：JS(ES6),VUE(非模块化实践),Element-ui 项目在线地址：https://www.i7xy.cn/code/PCB 线上项目vue和element-ui采用了cdn地址 1.对象拷贝 12// var m_process = process; // 这是直接复制地址... 必须用拷贝，这样复制的，如果修改m_process，原来的process也会受到影响var m_process = Object.assign(&#123;&#125;, process); // ES6的对象拷贝 2.解构赋值 1234[m_process.name, m_process.arriveTime, m_process.serviceTime] = processItem; //解构赋值，等同于下// m_process.name = processItem[0];// m_process.arriveTime = Number(processItem[1]);// m_process.serviceTime = Number(processItem[2]); 3.return返回多个内容，用解构赋值接收。 123456getAllProcess()&#123; return [m_allProcess, allTime];&#125;// 接收 ↓[this.allProcess, this.allTime] = this.getAllProcess(); 4.\{\{\}\} 换成 v-text，解决了线下和线上样式不匹配的问题。 5.canvas标签上定义的width和height并不是可视高度和宽度,这个可以通过css设置,标签上设置的为画图时候的参考高度和宽度. 代码托管于github,欢迎Start.项目在线地址：https://github.com/arleyGuoLei/pcb 5.vue加载渲染完之后,才显示页面 v-cloak https://cn.vuejs.org/v2/api/#v-cloak 123[v-cloak]&#123; display: none;&#125;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE官方文档笔记]]></title>
    <url>%2F2018%2F10%2F22%2FVUE%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看官方文档的时候，留下个脚印… vue vue-api vue-cli vuex vue-router Vue 不支持 IE8 及以下版本]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack - 前端构建模块化]]></title>
    <url>%2F2018%2F10%2F22%2Fwebpack-%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[学习了vue，回来补习webpack的洞了。 持续更新记录ing. 参考学习地址 1、文中node_modules/.bin/webpack app/main.js public/bundle.js运行之后会提示安装webpack-cli，安装之后，还是打包不了。 替换使用:npx webpack app/main.js --output public/bundle.js打包成功。 2、教程中的打包需要加上--mode developmentnode_modules/.bin/webpack --mode development 3、热更新，刷新网页 npm install --save-dev webpack-dev-server 在webpack的配置文件里添加 webpack.config.js 12345devServer: &#123; contentBase: "./public",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新&#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open"&#125; 执行npm run server]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Webpack</tag>
        <tag>模块化开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Js运行机制的理解]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%AF%B9Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Js是假的多线程，子线程由一个主线程控制，子线程不能操作DOM。基本意味着：同一个时间只能做一件事 为了提高CPU的利用率，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以这个标准并没有改变JavaScript单线程的本质 就喜欢案例… 1、12345console.log(1);// 同步任务，直接进入主线程执行，所以先输出1setTimeout(function()&#123; //setTimeout是异步任务，放进任务队列，等主线程调用 console.log(3);&#125;,0);console.log(2); 结果 123 2、1234567891011console.log("start");setTimeout(function () &#123; console.log("我是异步，放进任务队列等待主线程空闲后执行");&#125;, 0);setTimeout((function () &#123; console.log("我被放进了主线程，并且执行了");&#125;)(), 10000);//??? 迷惑 10s，是情况1还是2？ 网上两种解释都有，`"我被放进了主线程，并且执行了"` 通过立即执行函数，我觉得像是情况1// 1. 运行到setTimeout就把setTimeout的回调函数放入任务队列，10s后如果主线程空闲，即运行// 2. 运行到setTimeout，先不管，10s之后把回调函数放入任务队列，主线程如果这时候空闲，即运行console.log("over"); start我被放进了主线程，并且执行了over我是异步，放进任务队列等待主线程空闲后执行 3、 1234567891011console.log('1');setTimeout(function () &#123; console.log('5');&#125;, 0);new Promise(function (resolve, reject) &#123; console.log('2'); resolve();&#125;).then(function () &#123; console.log('4');&#125;);console.log('3'); 12345 4、12345console.log("1");setTimeout(function()&#123; console.log("2");&#125;,0);while(true)&#123;&#125; 1 , 主线程忙着跑死循环，不输出2.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math的三个取整方法区别]]></title>
    <url>%2F2018%2F10%2F20%2FMath%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%96%E6%95%B4%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Math.round() ： 四舍五入 Math.ceil() ： ceil为天花板意思，所以为向上取整。 让数尽量变大 Math.floor() ： floor为地板意思，所以为向下取整。 让数尽量变小 1.Math.round()：根据“round”的字面意思“附近、周围”，可以猜测该函数是求一个附近的整数，看下面几个例子就明白。 小数点后第一位&lt;5正数：Math.round(11.46)=11负数：Math.round(-11.46)=-11 小数点后第一位&gt;5正数：Math.round(11.68)=12负数：Math.round(-11.68)=-12 小数点后第一位=5正数：Math.round(11.5)=12负数：Math.round(-11.5)=-11总结：（小数点后第一位）大于五全部加，等于五正数加，小于五全不加。 2.Math.ceil()：根据“ceil”的字面意思“天花板”去理解；例如：Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=12Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-11 3.Math.floor()：根据“floor”的字面意思“地板”去理解；例如：Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=11Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-12]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js回调函数]]></title>
    <url>%2F2018%2F10%2F20%2FJs%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[主函数的事先干完，回头再调用传进来的那个函数。ES5 到 ES6，深入了解Promise 例一： 执行结果 A -&gt; B -&gt; C 123456789101112131415function a(callbackFunction) &#123; alert("A"); var m = "C"; return callbackFunction(m);&#125;function b(m) &#123; alert("B"); return m;&#125;var result = a(b);alert("result = " + result);// 执行结果 A -&gt; B -&gt; C 例二： 先输出 我是主函数，1s后输出我是回调函数 1234567891011//定义主函数，回调函数作为参数function A(callback) &#123; callback(); console.log('我是主函数');&#125;//定义回调函数function B() &#123; setTimeout("console.log('我是回调函数')", 1000);//模仿耗时操作 &#125;A(B); ES6 中用Promise解决回调的痛点，地址：ES6总结归纳]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些小前端DEMO]]></title>
    <url>%2F2018%2F10%2F19%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%89%8D%E7%AB%AFDEMO%2F</url>
    <content type="text"><![CDATA[自己平时学习过程中写的一些demo，整理贴，持续更新ing. 计算器：https://www.i7xy.cn/code/calc/ 响应式时间轴：https://www.i7xy.cn/code/timeline/ 爱心鱼(html-cavas游戏)：https://www.i7xy.cn/code/fish/ 点名系统(js练习 - JS失效 下载代码到本地看吧…)：https://www.i7xy.cn/code/getName/ 安卓机器人(CSS绘制)：https://www.i7xy.cn/code/android/ 七巧板(CSS绘制)：https://www.i7xy.cn/code/SevBoard/ 关于页面：https://www.i7xy.cn/code/about/ 多种方法实现一个页面的左中右布局：https://www.i7xy.cn/code/school/exp_10_2.html 普通企业网站首页布局(学校作业)：https://www.i7xy.cn/code/school/exp_10_1.html 手风琴Tab效果：https://www.i7xy.cn/code/accordionCSS/ 坑：display属性不能设置transition效果 旋转img：https://www.i7xy.cn/code/rotateImg/ VUE实现操作系统进程调度模拟https://www.i7xy.cn/code/PCB/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js闭包]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一般情况一个函数（函数作用域）执行完毕，里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，让作用域里面的变量，在函数执行完之后依旧保存没有被垃圾回收处理掉。 例1 12345678910111213141516171819202122232425262728293031function outer()&#123; var a = 1; function inner()&#123; return a++; &#125; return inner;&#125;var abc = outer();//outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中；//outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了；console.log(abc());//1console.log(abc());//2//因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的abc = null;//由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存；// 直接返回函数function outer2()&#123; var t = 1; return function ()&#123; console.log(t++); &#125;&#125;var a = outer2();a();//1a();//2a();//3a = null; 例2 12345678910function foo(tmp) &#123; return function () &#123; alert((tmp++)); &#125;&#125;var bar = foo(1); // bar 现在是一个闭包bar();//1bar();//2bar();//3bar();//4 例3 闭包混入立即执行函数 123456789var btnList = document.getElementsByClassName("btn"), len = btnList.length;for (var i = 0; i &lt; len; i++) &#123; (function (j) &#123; btnList[j].onclick = function () &#123; console.log("第" + j + "个按钮被点击到了") &#125; &#125;)(i)&#125; 这又哪里产生了闭包了。别急，我们一个个分析。for循环每一次都执行一个 IIEF （自执行函数），每一次变量 i 被当做参数传到IIEF中去 ， 那么这个自执行函数中创建了一个变量，参数 j 然后元素节点 btnList 绑定一个onclick事件，执行函数里面需要用到这个参数 j ，但是你又没点 ， 那么这个遍历 j 就没有被清理 ， 就一直在参数里面被保存着 ， 每一个IIEF都做一样的事情 ， 所以这个时候就产生了闭包 ， 变量 j 并没有被回收，依然在等待你使用。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js面试题整理]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[持续更新ing… 立即执行函数(IIFE) 立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了； 主要目的是做的一些封装，防止变量全局污染，以及保证内部变量的安全； javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用IIFE可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 123456var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下： 那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可（当然还有其他办法）： 12345678var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; (function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。 i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。 闭包将代码修改功能为一秒后输出1~5(在for循环之内完成)1234567for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, 1000 );&#125; 方法① 闭包 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (ii) &#123; setTimeout(function timer() &#123; console.log(ii); &#125;, 1000); &#125;)(i)&#125; 方法② let 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, 1000);&#125; 第二题 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; //面试经典问题: function onMyLoad()&#123; /* 抛出问题: 此题的目的是想每次点击对应目标时弹出对应的数字下标 0~4,但实际是无论点击哪个目标都会弹出数字5 问题所在: arr 中的每一项的 onclick 均为一个函数实例(Function 对象),这个函数实例也产生了一个闭包域, 这个闭包域引用了外部闭包域的变量,其 function scope 的 closure 对象有个名为 i 的引用, 外部闭包域的私有变量内容发生变化,内部闭包域得到的值自然会发生改变 */ var arr = document.getElementsByTagName("p"); for(var i = 0; i &lt; arr.length;i++)&#123; arr[i].onclick = function()&#123; alert(i); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="onMyLoad()"&gt; &lt;p&gt;产品一&lt;/p&gt; &lt;p&gt;产品二&lt;/p&gt; &lt;p&gt;产品三&lt;/p&gt; &lt;p&gt;产品四&lt;/p&gt; &lt;p&gt;产品五&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 用多种方法解决 方法一 123456789101112131415/*解决思路: 增加若干个对应的闭包域空间(这里采用的是匿名函数),专门用来存储原先需要引用的内容(下标),不过只限于基本类型(基本类型值传递,对象类型引用传递) */for(var i = 0;i&lt;arr.length;i++)&#123; //声明一个匿名函数,若传进来的是基本类型则为值传递,故不会对实参产生影响, //该函数对象有一个本地私有变量arg(形参) ,该函数的 function scope 的 closure 对象属性有两个引用,一个是 arr,一个是 i //尽管引用 i 的值随外部改变 ,但本地私有变量(形参) arg 不会受影响,其值在一开始被调用的时候就决定了. (function (arg) &#123; arr[i].onclick = function () &#123; //onclick函数实例的 function scope 的 closure 对象属性有一个引用 arg, alert(arg); //只要 外部空间的 arg 不变,这里的引用值当然不会改变 &#125; &#125;)(i); //立刻执行该匿名函数,传递下标 i(实参)&#125; 方法二 12345678910111213/*解决思路: 将下标作为对象属性(name:"i",value:i的值)添加到每个数组项(p对象)中*/for(var i = 0;i&lt;arr.length;i++)&#123; //为当前数组项即当前 p 对象添加一个名为 i 的属性,值为循环体的 i 变量的值, //此时当前 p 对象的 i 属性并不是对循环体的 i 变量的引用,而是一个独立p 对象的属性,属性值在声明的时候就确定了 //(基本类型的值都是存在栈中的,当有一个基本类型变量声明其等于另一个基本变量时,此时并不是两个基本类型变量都指向一个值,而是各自有各自的值,但值是相等的) arr[i].i = i; arr[i].onclick = function () &#123; alert(this.i); &#125;&#125; 方法三 123456789101112131415/*解决思路: 与解决办法一有点相似但却有点不太相似. 相似点:同样是增加若干个对应的闭包域空间用来存储下标 不同点:解决办法一是在新增的匿名闭包空间内完成事件的绑定,而此例是将事件绑定在新增的匿名函数返回的函数上 此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg */for(var i = 0; i&lt;arr.length;i++)&#123; arr[i].onclick = (function(arg)&#123; return function () &#123; alert(arg); &#125; &#125;)(i);&#125; 方法四 1234567891011/*解决思路与解决办法一相同 */for(var i = 0; i&lt;arr.length;i++)&#123; (function()&#123; var temp = i; arr[i].onclick = function () &#123; alert(temp); &#125; &#125;)();&#125; 方法五 1234567891011/*解决思路与解决办法三及四相同 */for(var i = 0;i&lt;arr.length;i++)&#123; arr[i].onclick = (function () &#123; var temp = i; return function () &#123; alert(temp); &#125; &#125;)();&#125; 方法六 12345678"use strict";//使用严格模式,否则报错 SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict modevar arr = document.getElementsByTagName("p");for(var i = 0;i&lt;arr.length;i++)&#123; let j = i;//创建一个块级变量 arr[i].onclick = function () &#123; alert(j); &#125;&#125; 本题自己做计算器的时候测试了一部分方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//方法一for (var i = 0; i &lt; numDom.length; i++) &#123; (function(val)&#123; numDom[val].onclick = function()&#123; var num = numDom[val].getAttribute("data-num"); result.value = num; &#125; &#125;)(i);&#125;// 方法二for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = function () &#123; var num = numDom[this.i].getAttribute("data-num"); result.value = num; &#125;&#125;// 方法三for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = (function (arg) &#123; return function()&#123; var num = numDom[arg].getAttribute("data-num"); result.value = num; &#125; &#125;)(i); &#125;// 方法四for (var i = 0; i &lt; numDom.length; i++) &#123; (function () &#123; var temp = i; numDom[i].onclick = function () &#123; var num = numDom[temp].getAttribute("data-num"); result.value = num; &#125; &#125;)();&#125;// 方法五for (var i = 0; i &lt; numDom.length; i++) &#123; numDom[i].i = i; numDom[i].onclick = (function () &#123; var temp = i; return function () &#123; var num = numDom[temp].getAttribute("data-num"); result.value = num; &#125; &#125;)();&#125; 立即执行函数 和 闭包 顺序深入的一道题1、123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; 没任何坑，输出 0~4 2、12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 3、改为闭包+立即执行函数1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; 输出0~4 4、删掉立即执行函数的i，不接收传值1234567for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 5、立即执行函数12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout( (function(i) &#123;console.log(i);&#125;)(i) , i * 1000);&#125; 直接立马输出0~4 setTimeout的第一个参数应该是一个函数（所以这个等同于：setTimeout(undefined, …);） 6、JavaScript 的运行机制相关12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 2 3 5 4 1 回调函数题目：红灯三秒亮一次，绿灯两秒亮一次，黄灯一秒亮一次；如何让三个灯不断交替重复亮灯？三个亮灯函数已经存在： 1234567891011function red()&#123; console.log('red - ', new Date());&#125;function green()&#123; console.log('green - ', new Date());&#125;function yellow()&#123; console.log('yellow - ', new Date());&#125; 1、es5 回调函数实现 123456789101112131415161718192021function showRed(callback)&#123; setTimeout(function()&#123; red(); callback(showYellow); &#125;, 3000);&#125;function showGreen(callback)&#123; setTimeout(function()&#123; green(); callback(showRed); &#125;, 2000)&#125;function showYellow(callback)&#123; setTimeout(function()&#123; callback(showGreen); yellow(); &#125;, 1000)&#125;showRed(showGreen); 避免博客重复，ES6 Promise 回调至 ES6面试题整理]]></content>
      <categories>
        <category>面试集锦</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js立即执行函数(转)]]></title>
    <url>%2F2018%2F10%2F18%2FJs%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这是 JS 中的一个常见概念，面试时经常会被问到，请「用自己的语言」简述 立即执行函数是什么 立即执行函数有什么用途 立即执行函数是什么立即执行函数就是 声明一个匿名函数 马上调用这个匿名函数 上面是一个典型的立即执行函数。 首先声明一个匿名函数 function(){alert(&#39;我是匿名函数&#39;)}。然后在匿名函数后面接一对括号 ()，调用这个匿名函数。 那么为什么还要用另一对括号把匿名函数包起来呢？其实是为了兼容 JS 的语法。 如果我们不加另一对括号，直接写成 function(){alert(‘我是匿名函数’)}()浏览器会报语法错误。想要通过浏览器的语法检查，必须加点小东西，比如下面几种 12345678( function()&#123;alert('我是匿名函数')&#125;() ) // 用括号把整个表达式包起来( function ()&#123; alert('我是匿名函数')&#125; )() //!function()&#123;alert('我是匿名函数')&#125;() // 求反，我们不在意值是多少，只想通过语法检查。+function()&#123;alert('我是匿名函数')&#125;()-function()&#123;alert('我是匿名函数')&#125;()~function()&#123;alert('我是匿名函数')&#125;()void function()&#123;alert('我是匿名函数')&#125;()new function()&#123;alert('我是匿名函数')&#125;() 立即执行函数有什么用？只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免「变量污染」）。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6面试题整理]]></title>
    <url>%2F2018%2F10%2F18%2FES6%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[这年头，到处都是ES6…持续更新ing… let和const let是更完美的var，不是全局变量，具有块级函数作用域,大多数情况不会发生变量提升。const定义常量值，不能够重新赋值，如果值是一个对象，可以改变对象里边的属性值。 1、let声明的变量具有块级作用域2、let声明的变量不能通过window.变量名进行访问3、形如for(let x..)的循环是每次迭代都为x创建新的绑定 下面是var带来的不合理场景 1234567var arr = [];for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[5]() //10 在上述代码中，变量i是var声明的，在全局范围类都有效，所以用来计数的循环变量泄露为全局变量。所以每一次循环，新的i值都会覆盖旧值，导致最后输出都是10。 而如果对循环使用let语句的情况，那么每次迭代都是为x创建新的绑定代码如下： 1234567var arr = [];for (let i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[5]() //5,a[5]输出f()&#123;console.log(i);&#125;,后面加个括号代表执行f() 【拓展】当然，除了这种方式让数组找中的各个元素分别是不同的函数，我们还可以采用ES5中的闭包和立即函数两种方法。 1、采用闭包12345678910function showNum(i) &#123; return function () &#123; console.log(i) &#125;&#125;var a = []for (var i = 0; i &lt; 5; i++) &#123; a[i] = showNum(i)(); //循环输出1,2,3,4&#125;//a的每一个成员都是undefined 2、采用立即执行函数123456789var a = []for (var i = 0; i &lt; 5; i++) &#123; a[i] = (function (i) &#123; return function () &#123; console.log(i) &#125; &#125;)(i)&#125;a[2](); //2 【面试】把以下代码使用两种方法，依次输出0-9 123456789var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func(); //输出十个10&#125;) 方法一：使用立即执行函数 12345678910111213var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push( ( function (value) &#123;return function () &#123;console.log(value)&#125;&#125;(i) ) )&#125;funcs.forEach(function (func) &#123; func(); //依次输出0-9&#125;) 看方法一的时候，会有和我一样心情的人么 ↓？得，我去补习js闭包和立即执行函数的知识...了1234(function(val)&#123;console.log(val);&#125;)("这样输出很牛b？");(function () &#123; return function (val) &#123; console.log(val); &#125; &#125;)()("那我可就更牛b了");(function()&#123;return (function () &#123; return function (val) &#123; console.log(val); &#125; &#125;)()("你怎么不牛b死呢")&#125;)();( function() &#123; return (function()&#123;console.log("哈哈，我笑笑不说话");&#125;)() &#125; ) (); 方法二：使用闭包 123456789101112function show(i) &#123; return function () &#123; console.log(i) &#125;&#125;var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(show(i))&#125;funcs.forEach(function (func) &#123; func(); //0 1 2 3 4 5 6 7 8 9&#125;) 方法三：使用let 123456789var funcs = []for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func(); //依次输出0-9&#125;) 知识回顾(forEach) 123456789//forEach 回顾var numbers = [4, 9, 16, 25];numbers.forEach(function(item,index)&#123; console.log("num[" + index + "] = "+item);&#125;);// num[0] = 4// num[1] = 9// num[2] = 16// num[3] = 25 Promise一、题目：红灯三秒亮一次，绿灯两秒亮一次，黄灯一秒亮一次；如何让三个灯不断交替重复亮灯？三个亮灯函数已经存在： 1234567891011function red()&#123; console.log('red - ', new Date());&#125;function green()&#123; console.log('green - ', new Date());&#125;function yellow()&#123; console.log('yellow - ', new Date());&#125; 答案： 12345678910111213141516171819202122232425262728293031//亮灯函数function tip(fn, timer) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; fn(); resolve(); &#125;, timer); &#125;);&#125;var promise = new Promise(function (resolve) &#123; resolve();&#125;);function loop() &#123; promise.then(function () &#123; return tip(red, 3000) &#125;) .then(function () &#123; return tip(green, 2000) &#125;) .then(function () &#123; return tip(yellow, 1000) &#125;) .then( function () &#123; loop(); &#125; )&#125;loop(); 二、以下代码依次输出的内容是？ 12345678910111213setTimeout(function () &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function () &#123; console.log(4);&#125;);console.log(5); 23541 首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。 三、jQuery的ajax返回的是promise对象吗？ jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。var jsPromise = Promise.resolve($.ajax(‘/whatever.json’)); 四、promise只有2个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？ 使用promise.all() 12345678910Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。Promise.all方法接受一个数组作为参数，数组里的元素都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）示例：var p =Promise.all([p1,p2,p3]);p的状态由p1、p2、p3决定，分为两种情况。当该数组里的所有Promise实例都进入Fulfilled状态：Promise.all**返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数**。当该数组里的某个Promise实例都进入Rejected状态：Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。 五、分析下列程序代码，得出运行结果，解释其原因 123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 1243 原因：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 六、写运行结果 12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error('error!!!')&#125;)console.log('promise1', promise1)console.log('promise2', promise2)setTimeout(() =&gt; &#123; console.log('promise1', promise1) console.log('promise2', promise2)&#125;, 2000) 七、分析下列程序代码，得出运行结果，解释其原因 12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) then success1 原因：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，promise 状态一旦改变则不能再变。 八、分析下列程序代码，得出运行结果，解释其原因 1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 1 2 原因：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。 九、分析下列程序代码，得出运行结果，解释其原因 1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('once') resolve('success') &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) oncesuccess 1001success 1001 原因：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 十、分析下列程序代码，得出运行结果，解释其原因 1234567891011Promise.resolve() .then(() =&gt; &#123; return new Error('error!!!') //运行.then //throw Error('error!!!') //运行.catch 必须throw &#125;) .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) then: Error: error!!! at Promise.resolve.then 原因.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：return Promise.reject(new Error(‘error!!!’))throw new Error(‘error!!!’) 因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。 十一、分析下列程序代码，得出运行结果，解释其原因 12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 1234567891011运行结果TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3原因.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。 十二、分析下列程序代码，得出运行结果，解释其原因 1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 12345运行结果1原因.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 十三、分析下列程序代码，得出运行结果，解释其原因 123456789Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;) 1234567运行结果fail2: Error: error at success (...) at ...原因.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。 字符串一、模拟一个模板字符串的实现。 12345678let address = '北京海淀区'let name = 'lala'let str = '$&#123;name&#125;在$&#123;address&#125;上班...'// 模拟一个方法 myTemplate(str) 最终输出 'lala在北京海淀区上班...'function myTemplate(str) &#123; // try it&#125;console.log(myTemplate(str)) // lala在北京海淀区上班... 我的答案： 123456789101112131415161718let address = '华北科技学院'let name = 'Arley'let str = '$&#123;name&#125;在$&#123;address&#125;上学...'// 模拟一个方法 myTemplate(str) 最终输出 'Arley在华北科技学院上学...'function myTemplate(str) &#123; try it let arr = str.match(/\$&#123;(.*?)&#125;/g); arr.forEach(item =&gt; &#123; let itemIn = item.substring(2, item.length - 1); let val = eval(itemIn); str = str.replace(item,val); &#125;); return str; // 人家的答案- - 一句话。 // return str.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; eval(key));&#125;console.log(myTemplate(str)) // Arley在华北科技学院上学... 顺便复习一下正则，原来replace可以这么用 12345678910111213let str = '$&#123;name&#125;在$&#123;address&#125;上学...'let s = str.match(/\$\&#123;(.*?)\&#125;/g);s.forEach((item,key) =&gt; &#123; console.log(item,key);&#125;);str.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; &#123; console.log(key,match);&#125;);// $&#123;name&#125; 0// $&#123;address&#125; 1// name $&#123;name&#125;// address $&#123;address&#125; 二、实现标签化模板(自定义模板规则)。 123456789const name = 'cc'const gender = 'male'const hobby = 'basketball'// 实现tag最终输出 '姓名：**cc**，性别：**male**，爱好：**basketball**'function tag(strings) &#123; // do it&#125;const str = tag`姓名：$&#123;name&#125;，性别：$&#123;gender&#125;，爱好：$&#123;hobby&#125;`console.log(str) // '姓名：**cc**，性别：**male**，爱好：**basketball**' 我的答案： 12345678910const name = 'cc'const gender = 'male'const hobby = 'basketball'// 实现tag最终输出 '姓名：**cc**，性别：**male**，爱好：**basketball**'function tag(strings) &#123; return strings.replace(/\$\&#123;(.*?)\&#125;/g, (match, key) =&gt; eval(key));//HIHI 变聪明了 我也一句话～&#125;const str = tag("`姓名：$&#123;name&#125;，性别：$&#123;gender&#125;，爱好：$&#123;hobby&#125;`")console.log(str) // '姓名：**cc**，性别：**male**，爱好：**basketball**' 字符串更多用法到 ES6总结归纳 箭头函数123var f = x =&gt; x; f(1); //return 1var f = x =&gt; &#123;x&#125;; f(1); //function(x)=&#123;x&#125;;var f = x =&gt; (&#123;x&#125;) ;f(1);//return &#123;1&#125;(返回一个对象) 讲解在 ES6总结归纳 解构123456789// 请使用 ES6 重构一下代码// 第一题var jsonParse = require('body-parser').jsonParse// 第二题var body = request.bodyvar username = body.usernamevar password = body.password 1234567//第一题import &#123; jsonParse &#125; from 'body-parser'//第二题const &#123; username, password &#125; = request.body//const &#123; body, body: &#123; username, password &#125; &#125; = requestconsole.log(`$&#123;username&#125; - - - $&#123;password&#125;`);]]></content>
      <categories>
        <category>面试集锦</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6总结归纳]]></title>
    <url>%2F2018%2F10%2F18%2FES6%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[学习了ES6之后，感觉内容很多，保持二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。 一.变量声明const和let const 和 let 的作用域为最近相邻的{} 12345678910111213function f()&#123; if(1!==1)&#123; let test = 'hello ES6'; &#125;else&#123; console.log(test); //let和const报错，var 定义的时候不报错 // var会变量提升至函数顶部 // var 时候 test = undefined； // let 和 const 报错：Uncaught ReferenceError: test is not defined &#125;&#125;f(); const定义变量之后不可以在修改值，但如果值为对象，仍可以修改对象内的赋值。 1234567891011const name = 'a'name = 'b' // 再次赋值此时会报错// Uncaught TypeError: Assignment to constant variable.const stu = &#123; id:1, name:'lei'&#125;;stu.id = 2;console.log(stu);//不会报错 TDZ(暂时性死区) 我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。 面试题 要求：更改代码，成功输出0到9； 题目代码 12345678var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; func()&#125;)//结果输入 10次10 我的投机取巧方法 12345678var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func,index) &#123; // func() console.log(index);&#125;) 方案① 123456789//ES6处理var funcs = []for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;//funcs.forEach(function (func) &#123;// func()//&#125;)funcs.forEach(func =&gt; func()) 方案② 12345678910var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function () &#123; console.log(i) &#125;)() )&#125;// funcs.forEach(function (func) &#123;// func()// &#125;)// 直接在push的时候调用函数 知识回顾123456789//forEach 回顾var numbers = [4, 9, 16, 25];numbers.forEach(function(item,index)&#123; console.log("num[" + index + "] = "+item);&#125;);// num[0] = 4// num[1] = 9// num[2] = 16// num[3] = 25 二.Promise 解决回调函数的异步痛点，用同步代码实现异步功能。 thenthen的第二个参数reject(B)，基本省略，最后用catch解决。 如果then()方法中返回了一个参数值，那么返回的Promise将会变成接收状态。如果then()方法中抛出了一个异常，那么返回的Promise将会变成拒绝状态。如果then()方法调用resolve()方法，那么返回的Promise将会变成接收状态。如果then()方法调用reject()方法，那么返回的Promise将会变成拒绝状态。如果then()方法返回了一个未知状态(pending)的Promise新实例，那么返回的新Promise就是未知状态。如果then()方法没有明确指定的resolve(data)/reject(data)/return data时，那么返回的新Promise就是接收状态，可以一层一层地往下传递。 看专业术语迷糊…看代码中的解释就懂了。 1234567891011121314151617181920212223242526272829303132333435363738394041promise = new Promise( // A ：resolve // B : reject function (A, B) &#123; setTimeout(() =&gt; &#123; // 此处不执行A或者B ， 直接return 或者 不返回任何内容，下面的then将不执行 A("获取数据完成");//A是获取成功 // 执行下面的then的第一个参数函数 //AB同时存在，只运行第一个，所以要运行B，需要注释了A B("获取数据失败"); //B是获取失败，执行下面的then的第二个参数函数 &#125;, 500) &#125;);promise.then( function (data) &#123; // 一. 运行下一个then的第一个函数 console.log("A" + data);//1. 不return 没返回任何内容 // return "返回参数值"; //2. return一个参数值 // return new Promise(function(A)&#123;A()&#125;); //3.调用了新的Promise的resolve方法，也就是A方法。注意：需要return，否则当做没情况1处理 // --------------- 下面两种运行下一个then的第二个函数 // return new Promise(function(A,B)&#123;B()&#125;);// 1.调用了新的Promise的reject方法，也就是B方法 注意要return. throw("抛出异常"); // 2.抛出异常 &#125;, function (data) &#123; console.log("B" + data);//上一个运行A()的话 此处不运行，运行B才运行。 &#125;).then( function () &#123; console.log("上面的then 1.没返回任何内容，2.或者返回参数值，3.或者调用resolve()方法"); &#125;, function () &#123; console.log("上面的then1.抛出了一个异常，2.或者调用reject()方法"); &#125;); catch catch()方法和then()方法一样，都会返回一个新的Promise对象，它主要用于捕获异步操作时出现的异常。因此，我们通常省略then()方法的第二个参数，把错误处理控制权转交给其后面的catch()函数，如下： 1234567891011121314151617181920212223promise = new Promise( function (A) &#123; setTimeout(() =&gt; &#123; A("获取数据完成"); &#125;, 500) &#125;);promise.then( function (data) &#123; console.log("上面执行了A"); throw ("我要抛出异常") &#125;).then( function () &#123; console.log("运行不到我了"); &#125;).catch( function (err) &#123; // 最后的catch()方法可以捕获在这一条Promise链上的异常 console.log(err);// 出错：reject &#125;) all 合并多个promise异步之后的数据 Promise.all里的任务列表[asyncTask(1),asyncTask(2),asyncTask(3)]，是按顺序发起的，由于它们都是异步的，互相之间并不阻塞，每个任务完成时机是不确定的。尽管如此，所有任务结束之后，它们的结果仍然是按顺序地映射到resultList里，这样就能和Promise.all里的任务列表[asyncTask(1),asyncTask(2),asyncTask(3)]一一对应起来。(转) 123456789101112131415const getRandom = () =&gt; +(Math.random() * 1000).toFixed(0);const asyncTask = taskID =&gt; new Promise(resolve =&gt; &#123; let timeout = getRandom(); console.log(`taskID=$&#123;taskID&#125; start.`); setTimeout(function () &#123; console.log(`taskID=$&#123;taskID&#125; finished in time=$&#123;timeout&#125;.`); resolve(taskID) &#125;, timeout);&#125;);Promise.all([asyncTask(1), asyncTask(2), asyncTask(3)]) .then(resultList =&gt; &#123; console.log('results:', resultList); &#125;); racePromise.race()和Promise.all()类似，都接收一个可以迭代的参数，但是不同之处是Promise.race()的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该Promise的状态就是改变的状态。就跟race单词的字面意思一样，谁跑的快谁赢。如下： 12345678910111213141516171819var p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(function(data) &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;); 三.字符串字符模板123var const = "Js";document.write("hello" + name + "!!!&lt;BR&gt;"); //es5document.write(`es6 $&#123;name&#125;!!!&lt;BR&gt;`); //es6 12345678// ES5var msg = "Hi \man!"// ES6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` ES6新加常用12345678910111213141516171819202122232425// 1.includes：判断是否包含然后直接返回布尔值 类似indexOfconst str = 'hahay'console.log(str.includes('y')) // true// 2.repeat: 获取字符串重复n次const str = 'he'console.log(str.repeat(3)) // 'hehehe'//如果你带入小数, Math.floor(num) 来处理// s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理// 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束const str = 'hello world!'console.log(str.startsWith('hello')) // trueconsole.log(str.endsWith('!')) // true// 4. padStart 和 padEnd 填充字符串，应用场景：时分秒// 上面代码中，padStart 和 padEnd 一共接受2个参数，第一个是用来指定字符串的最小长度，第二个参数是用来补全长度的字符串。// 1）如果原字符串长度等于或大于指定得最小长度，则返回原字符串。setInterval(() =&gt; &#123; const now = new Date() const hours = now.getHours().toString() const minutes = now.getMinutes().toString() const seconds = now.getSeconds().toString() console.log(`$&#123;hours.padStart(2, 0)&#125;:$&#123;minutes.padStart(2, 0)&#125;:$&#123;seconds.padStart(2, 0)&#125;`)&#125;, 1000) 四.函数函数默认参数123function test(num = 666) &#123; console.log(num)&#125; 箭头函数三个特点 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字 当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如: var people = name =&gt; &#39;hello&#39; + namevar people = () =&gt; &#39;hello i7xy&#39; 1234var hiPeople = (name) =&gt; &#123; const hi = 'hello' + name return hi&#125; 箭头函数需要注意的地方当要求动态上下文的时候，就不能够使用箭头函数，也就是this的固定化。 1、在使用=&gt;定义函数的时候，this的指向是定义时所在的对象，而不是使用时所在的对象；2、不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误；3、不能够使用arguments对象；4、不能使用yield命令； 12345678910111213class Animal &#123; constructor() &#123; this.type = "animal"; &#125; say(val) &#123; setTimeout(() =&gt; &#123; console.log(this); //Animal console.log(this.type + ' says ' + val); &#125;, 1000) &#125;&#125;var animal = new Animal();animal.say("hi"); //animal says hi 五.对象拓展（转）对象初始化简写 ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如： 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;;&#125; 键值对重名，ES6可以简写如下： 123456function people(name, age) &#123; return &#123; name, age &#125;;&#125; ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法： 123456const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125;&#125; ES6通过省略冒号与 function 关键字，将这个语法变得更简洁 123456const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125;&#125; ES6 对象提供了 Object.assign()这个方法来实现浅复制。Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}1234567891011121314const objA = &#123; name: 'cc', age: 18 &#125;const objB = &#123; address: 'beijing' &#125;const objC = &#123;&#125; // 这个为目标对象const obj = Object.assign(objC, objA, objB)// 我们将 objA objB objC obj 分别输出看看console.log(objA) // &#123; name: 'cc', age: 18 &#125;console.log(objB) // &#123; address: 'beijing' &#125;console.log(objC) // &#123; name: 'cc', age: 18, address: 'beijing' &#125;console.log(obj) // &#123; name: 'cc', age: 18, address: 'beijing' &#125;// 是的，目标对象ObjC的值被改变了。// so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象&#123;&#125;Object.assign(&#123;&#125;, objC, objA, objB) 六.更方便的数据访问–解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下： 1234567const people = &#123; name: 'man', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象const people = &#123; name: 'man', age: 20&#125;const &#123; name, age &#125; = peopleconsole.log(`$&#123;name&#125; --- $&#123;age&#125;`)//数组const color = ['red', 'blue']const [first, second] = colorconsole.log(first) //'red'console.log(second) //'blue' 七.Spread Operator 展开运算符…1234567891011121314//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c"// const objA = &#123; name: 'cc', age: 18 &#125;// const objB = &#123; address: 'beijing' &#125;// const objC = &#123;&#125; // 这个为目标对象// const obj = Object.assign(objC, objA, objB) 有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项 12345678910111213//数组const number = [1,2,3,4,5]const [first, ...rest] = numberconsole.log(rest) //2,3,4,5//对象const user = &#123; username: 'lux', gender: 'female', age: 19, address: 'peking'&#125;const &#123; username, ...rest &#125; = userconsole.log(rest) //&#123;"address": "peking", "age": 19, "gender": "female" 八.SET - 数组去重123const set = new Set([1,2,3,4,4])console.log([...set] )// [1,2,3,4]console.log(Array.from(new Set([2,3,3,5,6]))); //[2,3,5,6] 九.import 和 export12345678910111213141516171819202122232425//A.jsexport let A = 1;export function Test()&#123;&#125;export class Hello&#123;cat()&#123;&#125;&#125;//importX.js// import &#123; A, Test, Hello &#125; from './A';import * as lesson from './A';console.log(lesson.A, lesson.Test, lesson.Hello)// 更好的写法let A = 1;function Test()&#123;&#125;class Hello&#123;cat()&#123;&#125;&#125;export default &#123; A, Test, Hello&#125;// importX.jsimport Lesson from './A' 十.classES5继承与ES6继承的写法大比拼 123456789101112131415161718192021222324252627282930313233343536373839404142//ES5父类function User(name, age) &#123; this.name = name; this.age = age;&#125;//静态方法User.getClassName = function () &#123; return 'User';&#125;;//类的方法User.prototype.changeName = function (name) &#123; this.name = name;&#125;;User.prototype.changeAge = function (name) &#123; this.age = age;&#125;;Object.defineProperty(User.prototype, 'info', &#123; get() &#123; return 'name:' + this.name + ' | age:' + this.age; &#125;&#125;);var user = new User('feng', 23);console.log(user.info); // name:feng | age:23//子类function Manager(name, age, password) &#123; User.call(this, name, age); this.password = password;&#125;//继承静态方法Manager.__proto__ = User;//继承prototype方法Manager.prototype = User.prototype;//添加新方法Manager.prototype.changePassword = function (pwd) &#123; this.password = password;&#125;;var manager = new Manager('feng', 22, '556677');console.log(manager.name); //feng//调用changeName方法manager.changeName('feng xiong');console.log(manager.name); //feng xiong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ES6父类class User &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; //静态方法 static getClassName() &#123; return 'User'; &#125; //类的方法 changeName(name) &#123; this.name = name; &#125; changeAge(age) &#123; this.age = age; &#125; get info() &#123; return 'name:' + this.name + ' | age:' + this.age; &#125;&#125;var user = new User('fengg', 233);console.log(user.info); // name:fengg | age:233//子类class Manager extends User &#123; constructor(name, age, password) &#123; super(name, age); this.password = password; &#125; changePassword(password) &#123; this.password = password; &#125; get info()&#123; var info = super.info; console.log(info); return info + ' -- new'; &#125;&#125;var manager = new Manager('ES6feng', 22, '556677');console.log(manager.name); //ES6fengmanager.changeName('jack');console.log(manager.name); //jackconsole.log(manager.info);// name:jack | age:22// test.js:88 name:jack | age:22 -- new 十一.Symbolsymbol声明的变量是独一无二的。 1234567let a = Symbol();let b = Symbol();a === b;// falselet c = Symbol.for('ha');//c = Symbol(ha)let d = Symbol.for('ha');//d = Symbol(ha)c === d;// true 使用场景： 1234567891011121314151617181920212223242526let a1=Symbol.for('abc');let obj=&#123; [a1]:'123', 'abc':345, 'c':456&#125;;console.log('obj',obj);//&#123;abc:345 , c:456 ,Symbol(abc):"123"&#125;for(let [key,value] of Object.entries(obj))&#123; console.log('let of',key,value);&#125;// let of abc 345// let of c 456// PS:取不到Symbol的成员Object.getOwnPropertySymbols(obj).forEach(function(item)&#123; console.log(obj[item]);&#125;)// 123 只获取SymbolReflect.ownKeys(obj).forEach(function(item)&#123; console.log('ownkeys',item,obj[item]);&#125;)// ownkeys abc 345// ownkeys c 456// ownkeys Symbol(abc) 123 十二.Proxy 对对象的读取和设置进行拦截操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; let obj = &#123; id: 1, name: "arley", hobby: "学习" &#125; let proxy = new Proxy(obj, &#123; // 拦截设置 set(target, key, value) &#123; if (key === "hobby") &#123; return target[key] = "我爱" + value; &#125; &#125;, // 拦截获取 get(target, key) &#123; if (target[key] === 1) &#123; let value = String(target[key]); return target[key] = "2016070143" + value.padStart(2, 0); &#125; if (target[key] === "arley") &#123; return target[key] = "我是计科三班的同学."; &#125; return target[key]; &#125;, //拦截 key in object 操作 has(target,key)&#123; if(key === "name")&#123; return target[key]; &#125;else&#123; return false; &#125; &#125; &#125;); // console.log(proxy); // 1. console.log(proxy.name); // 当获取到的 target[key] === "arley" 的时候，返回 "我是计科三班的同学."; // 所以输出为：我是计科三班的同学. // 此时的获取器 get 中的值为： /* key = "name" target = Object &#123;id: 1, name: "arley", hobby: "学习"&#125; */ // 2. console.log(proxy.id) // 同1. 当id为1的时候，加入前缀 // 3. proxy.hobby = "ES6"; console.log(proxy.hobby); // set 的第三个参数 value 为 = 后面的内容，即ES6. // 所以设置之后的proxy.hobby = "我爱ES6",自动加上了前缀 // 4. obj 对象也会跟着改变 且 proxy 和 log值一样了。 console.log("obj:" + JSON.stringify(obj)); console.log("proxy:" + JSON.stringify(proxy)); // obj:&#123;"id":"201607014301","name":"我是计科三班的同学.","hobby":"我爱ES6"&#125; // proxy:&#123;"id":"201607014301","name":"我是计科三班的同学.","hobby":"我爱ES6"&#125; // 5.拦截 key in object console.log("key-&gt;","name" in proxy,"id" in proxy,"id" in obj); // key-&gt; true false true 注意：in obj 会返回true，因为没经过Proxy &#125; 十三.Iterator 以后学… 十四.Generator 以后学…]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次原生css3实现响应式布局 - timeLine]]></title>
    <url>%2F2018%2F10%2F06%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8E%9F%E7%94%9Fcss3%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80-timeLine%2F</url>
    <content type="text"><![CDATA[慕课网响应式布局教程 - 时间轴实战 1.分大 - 中 - 小 三种样式 大 &gt;768px 中 425 &lt; x＜=768 小 &lt;=425px 2.老师给的设计图 我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Time-line&lt;/title&gt; &lt;link rel="stylesheet" href="./css/normalize.css"&gt; &lt;link rel="stylesheet" href="./css/main.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;h1 class="title"&gt;Responsive Timeline&lt;/h1&gt; &lt;/header&gt; &lt;section class="main"&gt; &lt;ul class="item-all"&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;14:10&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Cumque, iste.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Consequatur eius illum libero maiores nam optio, praesentium provident sit suscipit! Aliquam animi asperiores consequuntur eaque facere, fugiat ipsa, ipsum libero magni officiis praesentium provident sequi suscipit vitae voluptatem voluptates voluptatibus. Beatae commodi cumque dignissimos doloremque ea facere id impedit ipsum iure mollitia natus pariatur, possimus quidem tempora vero? Dolorem, enim eos esse et eveniet excepturi iste laboriosam laudantium odit sit temporibus velit, veritatis voluptatem. Alias animi dicta ducimus, ipsam quidem repudiandae sint? Architecto atque beatae, consequuntur debitis nihil odit quo similique tenetur voluptates! Ad beatae, commodi illo molestiae quisquam sed veniam.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;15:30&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Neque, odio.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur dolorum enim id maxime quas qui reprehenderit sequi unde voluptatum. Accusantium consectetur ea impedit ipsam laboriosam perspiciatis quam! Architecto asperiores dolores doloribus ducimus enim esse fuga, harum iste iure libero maiores odit, officiis quae quibusdam quis sint veniam. Aperiam cupiditate, enim esse eum exercitationem fuga iste iusto perspiciatis sequi voluptatem! Aliquid animi asperiores at corporis, dolores eligendi laudantium libero minus non nostrum odio porro quo rem repellat sapiente sed sint, unde?&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item cleanfix"&gt; &lt;div class="item-left"&gt; &lt;span class="left-data"&gt;2018-10-05&lt;/span&gt; &lt;span class="left-time"&gt;16:40&lt;/span&gt; &lt;/div&gt; &lt;div class="item-right"&gt; &lt;div class="right-wrap"&gt; &lt;p class="right-title"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;p class="right-desc"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur autem cumque delectus, dolor doloribus ducimus eius error esse expedita explicabo hic incidunt laboriosam laudantium non obcaecati odio quae quam, quidem rem similique sit sunt temporibus ullam veritatis voluptate voluptatem, voluptatum. Aut commodi, debitis distinctio dolorum, ducimus eius eum excepturi facere fuga impedit molestias nam odio optio praesentium quibusdam quisquam reprehenderit repudiandae rerum saepe sint suscipit totam veniam. At dolores maxime officia quas repellendus rerum tempora tenetur? Aspernatur consectetur doloremque ea inventore maxime, sequi suscipit! Distinctio et numquam temporibus.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/** 大 &gt;768px* 中 425 &lt; x＜=768* 小 &lt;=425px*//*-----------------*/.cleanfix:before,.cleanfix:after &#123; display: table; content: ' ';&#125;.cleanfix:after &#123; clear: both;&#125;/*-----------------*/.container &#123; width: 100%; margin: 0 auto;&#125;@media screen and (min-width: 768px) &#123; .container &#123; max-width: 1080px; width: 90%; &#125;&#125;@media screen and (max-width: 768px)&#123; .container&#123; box-sizing: border-box; padding: 0 1rem; &#125;&#125;.title &#123; color: #47a3da; font-weight: 500; margin-top: 2.5rem;&#125;@media screen and (max-width: 768px)&#123; .title&#123; text-align: center; margin-top: 1.5rem; &#125;&#125;.main &#123; margin-top: 5rem; position: relative;&#125;.item-all:before &#123; position: absolute; content: ' '; width: .5rem; height: 100%; background-color: #afdcf8; left: 25%; top: 0; bottom: 0;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item-all:before &#123; left: 22%; &#125;&#125;@media screen and (max-width: 425px) &#123; .item-all:before &#123; display: none; &#125; .main &#123; margin-top: 2rem; &#125;&#125;.item-all .item:nth-child(2n) .right-wrap,.item-all .item:nth-child(2n) .item-right:before &#123; background-color: #3594CB;&#125;.item-all .item:nth-child(2n+1) .right-wrap,.item-all .item:nth-child(2n+1) .item-right:before &#123; background-color: #6CBFEE;&#125;.item-all&#123; padding: 0;&#125;.item &#123; list-style: none; position: relative; margin-bottom: 2rem;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item &#123; margin-bottom: 1rem; &#125;&#125;.item-left &#123; float: left; width: 30%; padding-right: 5rem; box-sizing: border-box; position: absolute; top: 0; bottom: 0;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .item-left &#123; padding-right: 10%; &#125;&#125;.item-right &#123; float: right; width: 70%; position: relative;&#125;.left-data &#123; font-size: 1rem; color: #bdd0db; display: block; text-align: right;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .left-data &#123; text-align: left; &#125;&#125;.item-all .item:nth-child(2n) .left-time &#123; color: #3594CB;&#125;.item-all .item:nth-child(2n+1) .left-time &#123; color: #6CBFEE;&#125;.left-time &#123; display: block; text-align: right; font-size: 3rem; font-weight: 400; margin-top: .2rem;&#125;@media screen and (max-width: 768px) and (min-width: 425px)&#123; .left-time &#123; font-size: 2rem; text-align: left; &#125;&#125;.right-wrap &#123; /*background-color: #6CBFEE;*/ border-radius: .4rem; padding: 2rem;&#125;.item-right:before &#123; position: absolute; content: ' '; display: block; width: 1.2rem; height: 1.2rem; /*background-color: #6CBFEE;*/ left: -.5rem; top: 2rem; transform: rotate(45deg);&#125;.right-title &#123; color: #ffffff; font-weight: 600; font-size: 1.5rem;&#125;.right-title:after &#123; content: ' '; display: block; height: 1px; background-color: #ffffff; margin-top: .8rem;&#125;.right-desc &#123; color: #ffffff; line-height: 1.5;&#125;@media screen and (max-width: 425px) &#123; .item-left &#123; float: none; width: 100%; display: block; position: relative; &#125; .item-right &#123; float: none; width: 100%; display: block; position: relative; margin-top: 1rem; &#125; .left-time&#123; text-align: left; font-size: 2rem; &#125; .left-data&#123; text-align: left; &#125; .item-right:before &#123; position: absolute; content: ' '; display: block; width: 1.2rem; height: 1.2rem; /* background-color: #6CBFEE; */ left: 2rem; top: -.5rem; transform: rotate(45deg); &#125;&#125; 老师的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en" class="no-js"&gt;&lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;title&gt;Responsive Timeline&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" type="text/css" href="css/style.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header class="clearfix"&gt; &lt;h1&gt;Responsive Timeline&lt;/h1&gt; &lt;/header&gt; &lt;div class="main"&gt; &lt;ul class="tmtimeline"&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-05-01&lt;/span&gt; &lt;span&gt;18:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Cupiditate, neque.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid architecto at atque consequatur consequuntur corporis dolor facere, fuga laborum natus, nihil rem repudiandae temporibus ullam ut veniam veritatis voluptas voluptates. Aliquam assumenda eius exercitationem hic ipsa numquam quam quis ratione, repellat, reprehenderit sunt, ullam! Accusamus, ad aliquid asperiores aspernatur at consequuntur cupiditate delectus deleniti dignissimos doloremque ea enim error, et excepturi explicabo facere fuga illo impedit iste laudantium minima molestias non nulla odit optio quos repellat sequi similique tempore vel veniam, vero voluptates voluptatum! At, cum deleniti, eaque enim fugiat illo in molestiae necessitatibus non obcaecati perferendis possimus temporibus tenetur.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-04-01&lt;/span&gt; &lt;span&gt;12:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Amet beatae cupiditate debitis doloribus eius eligendi, error est eveniet ipsam laborum laudantium magnam natus non omnis placeat praesentium quas repellat reprehenderit saepe soluta sunt temporibus totam vero voluptatem voluptatibus? Ab atque consequuntur cupiditate dolorum ducimus eligendi error eveniet excepturi facilis harum, in iste nihil obcaecati officiis, quas quasi qui quia quos reiciendis rem rerum sapiente totam unde voluptatibus voluptatum? Dolor dolore dolorum ducimus et fugit iusto modi odit quibusdam vitae voluptas!&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-03-21&lt;/span&gt; &lt;span&gt;11:30&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. At dignissimos dolor dolores error quisquam vero, voluptatem. Accusantium consectetur consequuntur debitis dicta dolor dolores fugit laborum libero molestiae, natus nobis odit. Ab aliquid consequuntur, dolorum eius eligendi impedit ipsam neque odit, perspiciatis quis, similique unde voluptate! Corporis necessitatibus odit repellendus tempora.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-02-11&lt;/span&gt; &lt;span&gt;9:45&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing.&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti, dolorem id inventore iste odit perferendis provident? A cupiditate doloribus, enim et fuga iste nemo non nostrum omnis perspiciatis praesentium provident, quas repellendus rerum sit tempore voluptates. Aliquam distinctio fugit hic maiores ullam voluptate! Aspernatur autem blanditiis deleniti dolor dolores dolorum enim et illum ipsa iure laboriosam, natus officiis ullam voluptas?&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;time class="tmtime"&gt;&lt;span&gt;2016-02-11&lt;/span&gt; &lt;span&gt;9:45&lt;/span&gt;&lt;/time&gt; &lt;div class="tmlabel"&gt; &lt;h2&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptas?&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Error eum ex iusto magnam obcaecati. Adipisci deserunt dicta dolorem ea enim et eum labore laboriosam, quos reprehenderit sequi vero vitae voluptatum.&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207*, *:after, *:before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;body, html &#123; margin: 0; padding: 0; font-size: 100%;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: table;&#125;.clearfix:after &#123; clear: both;&#125;body &#123; font-family: 'Lato', Calibri, Arial, sans-serif; color: #47a3da;&#125;a &#123; color: #f0f0f0; text-decoration: none;&#125;a:hover &#123; color: #000;&#125;.main,.container &gt; header &#123; width: 96%; max-width: 70em; margin: 0 auto; padding: 0 2em 3em 2em;&#125;.container &gt; header &#123; padding: 3em 2em 2em;&#125;.container &gt; header h1 &#123; font-weight: 400;&#125;@media screen and (max-width: 55em) &#123; .main, .container &gt; header &#123; width: 98%; padding: 0 2em 1em 2em; &#125; .container &gt; header h1 &#123; text-align: center; &#125;&#125;/* Timeline */.tmtimeline &#123; position: relative; margin: 30px 0 0 0; padding: 0; list-style: none;&#125;.tmtimeline:before &#123; content: ''; position: absolute; top: 0; bottom: 0; left: 20%; width: 10px; margin-left: -10px; background: #afdcf8;&#125;.tmtimeline &gt; li &#123; position: relative;&#125;.tmtimeline &gt; li .tmtime &#123; position: absolute; display: block; width: 25%; padding-right: 100px;&#125;.tmtimeline &gt; li .tmtime span &#123; display: block; text-align: right;&#125;.tmtimeline &gt; li .tmtime span:first-child &#123; font-size: 0.9em; color: #bdd0db;&#125;.tmtimeline &gt; li .tmtime span:last-child &#123; font-size: 2.9em; color: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmtime span:last-child &#123; color: #6cbfee;&#125;.tmtimeline &gt; li .tmlabel &#123; position: relative; margin: 0 0 15px 25%; padding: 2em; color: #fff; font-size: 1.2em; font-weight: 300; line-height: 1.4; border-radius: 5px; background: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmlabel &#123; background: #6cbfee;&#125;.tmtimeline &gt; li .tmlabel h2 &#123; margin-top: 0; padding: 0 0 10px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.4);&#125;.tmtimeline &gt; li .tmlabel:after &#123; content: " "; position: absolute; top: 10px; right: 100%; height: 0; width: 0; pointer-events: none; border: 10px solid transparent; border-right-color: #3594cb;&#125;.tmtimeline &gt; li:nth-child(odd) .tmlabel:after &#123; border-right-color: #6cbfee;&#125;@media screen and (max-width: 55em) &#123; .tmtimeline &gt; li .tmtime &#123; padding-right: 65px; &#125; .tmtimeline &gt; li .tmtime span:last-child &#123; font-size: 1.5em; &#125;&#125;@media screen and (max-width: 40em) &#123; .tmtimeline:before &#123; display: none; &#125; .tmtimeline &gt; li .tmtime &#123; position: relative; width: 100%; padding: 0 0 20px 0; &#125; .tmtimeline &gt; li .tmtime span &#123; text-align: left; &#125; .tmtimeline &gt; li .tmlabel &#123; margin: 0 0 30px 0; padding: 1em; font-weight: 400; font-size: 95%; &#125; .tmtimeline &gt; li .tmlabel:after &#123; top: -20px; right: auto; left: 20px; border-right-color: transparent; border-bottom-color: #3594cb; &#125; .tmtimeline &gt; li:nth-child(odd) .tmlabel:after &#123; border-right-color: transparent; border-bottom-color: #6cbfee; &#125; .tmtimeline &gt; li .tmicon &#123; position: relative; float: right; left: auto; margin: -55px 5px 0 0; &#125;&#125; normalize123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css *//** * 1. Change the default font family in all browsers (opinionated). * 2. Prevent adjustments of font size after orientation changes in IE and iOS. */html &#123; font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/** * Remove the margin in all browsers (opinionated). */body &#123; margin: 0;&#125;/* HTML5 display definitions ========================================================================== *//** * Add the correct display in IE 9-. * 1. Add the correct display in Edge, IE, and Firefox. * 2. Add the correct display in IE. */article,aside,details, /* 1 */figcaption,figure,footer,header,main, /* 2 */menu,nav,section,summary &#123; /* 1 */ display: block;&#125;/** * Add the correct display in IE 9-. */audio,canvas,progress,video &#123; display: inline-block;&#125;/** * Add the correct display in iOS 4-7. */audio:not([controls]) &#123; display: none; height: 0;&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Add the correct display in IE 10-. * 1. Add the correct display in IE. */template, /* 1 */[hidden] &#123; display: none;&#125;/* Links ========================================================================== *//** * 1. Remove the gray background on active links in IE 10. * 2. Remove gaps in links underline in iOS 8+ and Safari 8+. */a &#123; background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */&#125;/** * Remove the outline on focused links when they are also active or hovered * in all browsers (opinionated). */a:active,a:hover &#123; outline-width: 0;&#125;/* Text-level semantics ========================================================================== *//** * 1. Remove the bottom border in Firefox 39-. * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Prevent the duplicate application of `bolder` by the next rule in Safari 6. */b,strong &#123; font-weight: inherit;&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * Add the correct font style in Android 4.3-. */dfn &#123; font-style: italic;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/** * Add the correct background and color in IE 9-. */mark &#123; background-color: #ff0; color: #000;&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10-. */img &#123; border-style: none;&#125;/** * Hide the overflow in IE. */svg:not(:root) &#123; overflow: hidden;&#125;/* Grouping content ========================================================================== *//** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,pre,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct margin in IE 8. */figure &#123; margin: 1em 40px;&#125;/** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/* Forms ========================================================================== *//** * 1. Change font properties to `inherit` in all browsers (opinionated). * 2. Remove the margin in Firefox and Safari. */button,input,select,textarea &#123; font: inherit; /* 1 */ margin: 0; /* 2 */&#125;/** * Restore the font weight unset by the previous rule. */optgroup &#123; font-weight: bold;&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video` * controls in Android 4. * 2. Correct the inability to style clickable types in iOS and Safari. */button,html [type="button"], /* 1 */[type="reset"],[type="submit"] &#123; -webkit-appearance: button; /* 2 */&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Change the border, margin, and padding in all browsers (opinionated). */fieldset &#123; border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Remove the default vertical scrollbar in IE. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10-. * 2. Remove the padding in IE 10-. */[type="checkbox"],[type="radio"] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type="search"] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding and cancel buttons in Chrome and Safari on OS X. */[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * Correct the text style of placeholders in Chrome, Edge, and Safari. */::-webkit-input-placeholder &#123; color: inherit; opacity: 0.54;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;]]></content>
      <categories>
        <category>布局艺术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display: inline-block 导致换行]]></title>
    <url>%2F2018%2F10%2F02%2Fdisplay-inline-block-%E5%AF%BC%E8%87%B4%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[display: inline-block 时候，70% + 30% &gt; 100% 换行原因:标签与标签之间的换行会占据一定大小。 比如:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;`display: inline-block`导致换行&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; .containter .item:nth-child(1) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: red; height: 100px; &#125; .containter .item:nth-child(2) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: yellow; height: 100px; &#125; .containter .item:nth-child(3) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: blue; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="containter"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;!-- 因为item div之后的换行导致 --&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方法: 123.containter &#123; font-size: 0;&#125;]]></content>
      <categories>
        <category>布局艺术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-shadow 的参数（模糊距离与阴影尺寸的区别）]]></title>
    <url>%2F2018%2F10%2F02%2Fbox-shadow-%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E6%A8%A1%E7%B3%8A%E8%B7%9D%E7%A6%BB%E4%B8%8E%E9%98%B4%E5%BD%B1%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[box-shadow: h-shadow v-shadow blur spread color inset; box-shadow: 水平位移 垂直位移 模糊距离 阴影尺寸 color inset; 阴影尺寸:增加边框的宽度(不占据k空间) 模糊距离:模糊的圆的半径 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .shadow &#123; box-shadow:green 0 0 100px ; height: 100px; width: 100px; margin: 30px; float: left; &#125; .shadow_inset&#123; box-shadow: 0 0 100px red inset ; height: 100px; width: 100px; margin: 30px; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="shadow"&gt; &lt;/div&gt; &lt;div class="shadow_inset"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课 [所向披靡的响应式] 学习笔记]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%85%95%E8%AF%BE-%E6%89%80%E5%90%91%E6%8A%AB%E9%9D%A1%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[教程地址：慕课-所向披靡的响应式开发 1.判断IE版本 -&gt; IE低版本提示兼容,更新浏览器 123&lt;!--[if lte IE 8]&gt;&lt;p&gt;版本低&lt;/p&gt;&lt;![endif]--&gt; 2.lte 小于等于,gte 大于等于 3.id-&gt;首字母小写的驼峰命名,class-&gt; -连接单词 4.必不可少的图片img引入,k而有可无的装饰性图片css中用样式引入 5.选择文本之后的样式设置 1234::selection&#123; background-color: red; text-shadow: none;&#125; 6.清除浮动的方法 - 触发BFC 尾部添加div 1&lt;div style="clear:both;"&gt;&lt;/div&gt; 父元素设置样式(子元素设置了浮动) 1overfloat:hidden;//auto 或 1float:left; 最佳方法,在父元素结点上加入类clearfix,然后通过after除 1234567.clearfix:after&#123; content: ' '; display: block; height: 0; visibility: hidden; clear: both;&#125; 改进: 12345.clearfix:after&#123; content: ' '; display: table; clear: both;&#125; 7.防止上下margin叠加 12345678.clearfix:after,.clearfix:before&#123; content: ' '; display: table;&#125;.clearfix:after&#123; clear: both;&#125; 8.line-height设置高度为rem单位时候会出现高度不符合预期,尽量用px设置(因为浏览器有字体大小下限) 9.第一个li不设置左边框,后面的li设置:+ 1ul li + li&#123;&#125; 10.display: inline-block导致换行:标签与标签之间的换行会占据一定大小,导致换行. 比如:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;`display: inline-block`导致换行&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; .containter .item:nth-child(1) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: red; height: 100px; &#125; .containter .item:nth-child(2) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: yellow; height: 100px; &#125; .containter .item:nth-child(3) &#123; display: inline-block; width: 33.3333333333333333333%; background-color: blue; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="containter"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;!-- 因为item div之后的换行导致 --&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方法: 123.containter &#123; font-size: 0;&#125; 11.文本一行显示,超过的省略号截断.123text-overflow: ellipsis;overflow: hidden;white-space: nowrap; 12.为css自动加入浏览器识别前缀:autoprefixer 13.媒体查询 所以设置的常有：1234@media screen and (min-width:1200px)@media screen and (min-width:992px)@media screen and (min-width:768px)@media screen and (min-width:480px) 14.响应式图片 为了兼容所有低版本浏览器,引入picturefill库 12345&lt;picture&gt; &lt;source srcset="bigest.png" media="(min-width:50em)"&gt; &lt;source srcset="big.png" media="(min-width:30em)"&gt; &lt;img srcset="other.png" alt=""&gt;&lt;/picture&gt; 15.在线压缩图片:pngtiny 16.nodejs和npm npm install xxx -&gt; npm i xxxnpm i xxx -gnpm i xxx --savenpm i xxx --save-dev 17.modernizr 18.caniuse 19.browsersync 20.gulpjs 21.Webstorm常用 &gt;,+,^,*,() #,.,[] $ {},loremctrl + back 删除当前行ctrl + alt + 回车 在上方插入一行ctrl + +/- 折叠/打开代码ctrl + shift + +/- 折叠/打开所有代码]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2018%2F09%2F20%2FVscode%E7%9A%84Git%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写给自己 线上新建项目 线下： 1234567git initgit add .git commit -m &apos;xxx&apos;git remote add origin git@github.com:xxxxxxxx.gitgit branch --set-upstream-to=origin/master mastergit pull --allow-unrelated-histories 切换以前提交的head : git reset --hard xxxxxxxxxxxxxxxxxxxxx查看提交日志: git log查看所有提交: git reflog (包含git reset之后丢失的) git init git remote add origin git@github.com:arleyGuoLei/Travel.git git add . git commit -m ‘xxxx’ git push git pull git checkout FenZhi git status 在swiper分支上提交并且push 本地切换到master分支:git checkout master git merge origin/swiper git push 小结 在github上手动创建分支 本地 git pull 同步拉取线上分支 本地切换分支 git checkout [新分支] 写完代码之后:git add . 提交代码:git commit -m &#39;描述&#39; push到线上当前新建的分支:git push 切换到master分支:git checkout master 合并分支:git merge origin/[分支名] 提交代码:git push 直接初始化某个项目 1、在Git官网上点击New repository新建项目； 2、在本地新建一个同名文件； 3、打开git bash切换到新建的文件目录； 4、echo “# myprojectname”&gt;&gt;README.md; //新建一个README文件并写入内容 5、git init //git初始化 6、git add .将全部文件添加到git中；git add README.md 将README文件单独添加 7、git commit - m “first commit” //添加提交时的注释 8、git remote add origin git@github.com:xxxxxxxx.git //将git进行远程连线 9、git branch –set-upstream-to=origin/master master 10、git pull –allow-unrelated-histories 可能出现的错误 1、fatal: remote origin already exists.//连线已经存在 解决方法：执行 git remote rm origin 将已存在的连接删除 2、error:failed to push som refs to……. 解决方法：执行git pull origin master 先将远程服务器上的文件拉下来 3、fatal: refusing to merge unrelated histories”//本地的和GitHub上没有共同祖先 解决方法：执行git pull origin master –allow-unrelater-histories git其它：1.切换分支后要将本地与线上关联起来 ①切换分支 git checkout -b 分支名； ②关联 git branch –set-upstream-to=origin/远程分支名 本地分支名（不关联进行git操作时则提示 If you wish to set tracking information for this branch you can do so with: git branch –set-upstream-to=origin/ ***） 2.拒绝合并无关的历史git branch --set-upstream-to=origin/master master然后使用git pull整合远程仓库和本地仓库，git pull --allow-unrelated-histories (忽略版本不同造成的影响)]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>GIT</tag>
        <tag>GITHUB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的动画特效]]></title>
    <url>%2F2018%2F09%2F20%2FVUE%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[1 Vue动画 - Vue中CSS动画原理 在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; .slide-fade-enter-active, .slide-fade-leave-active &#123; transition: all .8s ease; &#125; .slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="slide-fade"&gt; &lt;p v-show="show"&gt;hello Arley~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 在Vue中使用 animate.css 库 animate通过定义keyframes动画实现动画 自定义动画类名 - 配合animateCss实现动画 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) vue Css3的animate实现动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; @keyframes bounce-in&#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5) &#125; 100% &#123; transform: scale(1) &#125; &#125; /* 隐藏到显示 */ .slide-fade-enter-active&#123; animation: bounce-in 2s ease-in-out; transform-origin: left center; &#125; /* 显示到隐藏 */ .slide-fade-leave-active &#123; animation: bounce-in 2s ease-in-out reverse; transform-origin: left center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="slide-fade"&gt; &lt;p v-show="show"&gt;hello Arley~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; animate.css + 自定义类名实现动画1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="animate.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition enter-active-class="animated rubberBand" leave-active-class="animated swing"&gt; &lt;p v-show="show"&gt;hello Arley~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中同时使用过渡和动画 页面载入时即执行初始动画 appear appear-active-class=”animated rubberBand” 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="animate.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition appear appear-active-class="animated rubberBand" enter-active-class="animated rubberBand" leave-active-class="animated swing"&gt; &lt;p v-show="show"&gt;hello Arley~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; animate动画和transition过渡同时使用 在自定义类名上加上将会自动生成的类名名字,然后再写css样式. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="animate.css"&gt; &lt;style&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-active,.fade-leave-active&#123; transition: opacity 3s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;!-- 通过type设置要以哪个类型作为动画时长 type="transition"--&gt; &lt;!-- 或者直接通过:duration 手动设置时长 --&gt; &lt;transition name="fade" appear appear-active-class="animated rubberBand" :duration="&#123;enter:2000,leavve:3000&#125;" enter-active-class="animated rubberBand fade-enter-active" leave-active-class="animated swing fade-leave-active"&gt; &lt;p v-show="show"&gt;hello Arley~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4 Vue中的 Js 动画与 Velocity.js 的结合 JavaScript钩子 12345678910111213&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 5 Vue中多个元素或组件的过渡 多个元素之间的动画过渡 v-if/v-else 混用 transition可以设置mode修改显示方式(过渡顺序) PS:两个元素之间的key需要不同,要不然vue会复用组件. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; @keyframes bounce-in&#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5) &#125; 100% &#123; transform: scale(1) &#125; &#125; /* 隐藏到显示 */ .slide-fade-enter-active&#123; animation: bounce-in 2s ease-in-out; transform-origin: left center; &#125; /* 显示到隐藏 */ .slide-fade-leave-active &#123; animation: bounce-in 2s ease-in-out reverse; transform-origin: left center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="slide-fade" mode="out-in"&gt; &lt;p v-if="show" key="hello"&gt;hello Arley~&lt;/p&gt; &lt;p v-else="show" key="bye"&gt;Bye~&lt;/p&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多个组件之间的过渡 设置两个组件的方式:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; @keyframes bounce-in&#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5) &#125; 100% &#123; transform: scale(1) &#125; &#125; /* 隐藏到显示 */ .slide-fade-enter-active&#123; animation: bounce-in 2s ease-in-out; transform-origin: left center; &#125; /* 显示到隐藏 */ .slide-fade-leave-active &#123; animation: bounce-in 2s ease-in-out reverse; transform-origin: left center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="slide-fade" mode="out-in"&gt; &lt;child-one v-if="show" &gt;&lt;/child-one&gt; &lt;child-two v-else="show"&gt;&lt;/child-two&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one', &#123; template:"&lt;div&gt;One.&lt;/div&gt;" &#125;) Vue.component('child-two', &#123; template:"&lt;div&gt;Two.&lt;/div&gt;" &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; change: function () &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态组件的方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;VueCss过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; @keyframes bounce-in&#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5) &#125; 100% &#123; transform: scale(1) &#125; &#125; /* 隐藏到显示 */ .slide-fade-enter-active&#123; animation: bounce-in 2s ease-in-out; transform-origin: left center; &#125; /* 显示到隐藏 */ .slide-fade-leave-active &#123; animation: bounce-in 2s ease-in-out reverse; transform-origin: left center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="slide-fade" mode="out-in"&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;button @click="change"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one', &#123; template:"&lt;div&gt;One.&lt;/div&gt;" &#125;) Vue.component('child-two', &#123; template:"&lt;div&gt;Two.&lt;/div&gt;" &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type:'child-one' &#125;, methods: &#123; change: function () &#123; this.type = this.type==="child-one"?'child-two':'child-one'; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6 Vue中的列表过渡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Vue列表过渡动画&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style&gt; .list-enter,.list-leave-to&#123; opacity: 0; &#125; .list-enter-active,.list-leave-active&#123; transition: opacity 1s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition-group name="list"&gt; &lt;div v-for="item in list" :key="item.id"&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var count = 0; var vm = new Vue(&#123; el: '#root', data: &#123; list:[] &#125;, methods: &#123; add: function () &#123; this.list.push(&#123; id:count++, title:'hello!' + count &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE组件之间传值整理]]></title>
    <url>%2F2018%2F09%2F19%2FVUE%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 使用组件的细节点1.is属性 ul/ol(li),table(tr)&lt;li is=&quot;xxx&quot;&gt;&lt;/li&gt; 2.自定义组件的data必须是一个函数 3.ref的使用 获取元素dom 计数器例子 1.Vue.component2.this.$emit(‘change’)3.@change=(“函数名”) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Counter&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;item-counter ref="one" @change="handleChange"&gt;&lt;/item-counter&gt; &lt;item-counter ref="two" @change="handleChange"&gt;&lt;/item-counter&gt; &lt;div&gt;&#123;&#123;sum&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component('item-counter',&#123; template:'&lt;div @click="bindCounter"&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;', data:function()&#123; return&#123; counter:0 &#125; &#125;, methods:&#123; bindCounter:function()&#123; this.counter++; this.$emit('change'); &#125; &#125; &#125;) var vm = new Vue(&#123; el:'#root', data:&#123; sum:0 &#125;, methods:&#123; handleChange:function()&#123; this.sum = this.$refs.one.counter + this.$refs.two.counter; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 父子组件间的数据传递 局部组件 先定义一个对象,然后在new Vue里的components去引用 父组件向子组件传递值 :绑定 比如 :count=”xxx” 向模板传入count参数,需要在模板定义的时候在props进行定义count 单项数据流(子组件禁止直接去修改父组件的值) 父组件的数据可能被多个地方调用,所以禁止修改,需要用自己的变量去接收,然后在修改. 子元素给父元素传值(带参数) 函数绑定的地方直接写函数名,不去要参数,然后在用的时候直接存入,在函数定义时候接收. 计数器2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Counter&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;item-counter :count="1" @inc="numberInc"&gt;&lt;/item-counter&gt; &lt;item-counter :count="1" @inc="numberInc"&gt;&lt;/item-counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; // @click="handCounter" 得写在模板上面,不能写在&lt;item-counter xxx(这) :count="1"&gt;&lt;/item-counter&gt; template: '&lt;div @click="handCounter"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', props: ['count'], data: function () &#123; return&#123; // 这里得return 拷贝一份父元素的number number: this.count &#125; &#125;, methods:&#123; handCounter:function()&#123; this.number++; this.$emit('inc',1); &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; 'item-counter':counter &#125;, data:&#123; total:2 &#125;, methods:&#123; numberInc:function(count)&#123; this.total+=count; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 组件参数校验以及非Props特性 Props的参数校验 123456789101112131415props: &#123; status: &#123; type: String, required: true, //返回true 校验通过 validator: function (value) &#123; return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 &#125; &#125;&#125; 非Props特性 父传子不接,用的不多. 4 给组件绑定原生事件1.low的写法 子元素先监听,然后this.$emit() 给父元素 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Counter&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;item-child @fun="handleClick"&gt;&lt;/item-child&gt; &lt;/div&gt; &lt;script&gt; Vue.component('item-child', &#123; template: '&lt;div @click="handleChild"&gt;Child&lt;/div&gt;', methods:&#123; handleChild:function()&#123; this.$emit('fun') &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function () &#123; alert("click."); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 好的写法 12345678910111213141516&lt;div id="root"&gt; &lt;item-child @click.native="handleClick"&gt;&lt;/item-child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('item-child', &#123; template: '&lt;div&gt;Child&lt;/div&gt;', &#125;) var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function () &#123; alert("click."); &#125; &#125; &#125;)&lt;/script&gt; 5 非父子组件之间的传值问题1.bus/发布订阅模式/观察者模式 this.bus.$emit() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;非父子组件间的传值&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;!-- 这里的content不能打: --&gt; &lt;item-child content="Arley"&gt;&lt;/item-child&gt; &lt;item-child content="GuoLei"&gt;&lt;/item-child&gt; &lt;/div&gt; &lt;script&gt; //关键↓ 1 Vue.prototype.bus = new Vue(); Vue.component('item-child', &#123; props: &#123; content: String &#125;, data: function () &#123; return &#123; selfContent: this.content &#125; &#125;, template: '&lt;div @click="changeItem"&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;', methods:&#123; changeItem:function()&#123; //关键↓ 2 this.bus.$emit('change',this.selfContent) &#125; &#125;, //关键↓ 3 mounted:function()&#123; var that = this; // 4 监听 this.bus.$on('change',function(msg)&#123; that.selfContent = msg; &#125;) &#125;, &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6 插槽(slot) 父组件优雅的向子组件传递Dom结构 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;插槽&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;body-content&gt; &lt;div slot="header"&gt;我是头部&lt;/div&gt; &lt;div slot="footer"&gt;我是底部&lt;/div&gt; &lt;/body-content&gt; &lt;/div&gt; &lt;script&gt; Vue.component('body-content', &#123; // 最外部必须套一个root根节点 template: ` &lt;div&gt; &lt;slot name='header'&gt;a&lt;/slot&gt; &lt;div&gt;我是内容&lt;/div&gt; &lt;slot name='footer'&gt;a&lt;/slot&gt; &lt;/div&gt; ` &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7 作用域插槽 子组件中留一部分代码,由父组件传入,决定渲染模式. 123456789101112131415161718192021222324252627&lt;div id="root"&gt; &lt;body-content&gt; &lt;template slot-scope="props"&gt; &lt;li&gt;&#123;&#123;props.item&#125;&#125; -- hello&lt;/li&gt; &lt;/template&gt; &lt;/body-content&gt;&lt;/div&gt;&lt;script&gt; Vue.component('body-content', &#123; data: function () &#123; return &#123; list: [1, 2, 3, 4, 5] &#125; &#125;, template: ` &lt;div&gt; &lt;ul&gt; &lt;slot v-for="item in list" :item=item&gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt; ` &#125;) var vm = new Vue(&#123; el: '#root' &#125;)&lt;/script&gt; 8 动态组件与 v-once 指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;插槽&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;!-- 写法1 low --&gt; &lt;!-- &lt;body-content-one v-if="type==='body-content-one'"&gt;&lt;/body-content-one&gt; &lt;body-content-two v-if="type==='body-content-two'"&gt;&lt;/body-content-two&gt; --&gt; &lt;!-- 直接根据 is的属性赋值模板 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;input type="button" value="切换" @click="change"&gt; &lt;/div&gt; &lt;script&gt; // v-once 能把组件保存在内容,第一次渲染之后不用再次渲染 Vue.component('body-content-one', &#123; template: "&lt;div v-once&gt;one&lt;/div&gt;" &#125;) Vue.component('body-content-two', &#123; template: "&lt;div v-once&gt;two&lt;/div&gt;" &#125;) var vm = new Vue(&#123; el: '#root', data:&#123; type:'body-content-one' &#125;, methods:&#123; change:function()&#123; this.type = (this.type==='body-content-one'?'body-content-two':'body-content-one'); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
</search>
